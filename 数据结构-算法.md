## 基础数据结构

### 二叉排序树

二叉排序树（Binary Sort Tree）：树上的节点是已经排好序的，具体的排序规则如下：

- 若左子树不空，则左子树上所有节点的值均小于它的根节点的值
- 若右子树不空，则右字数上所有节点的值均大于它的根节点的值
- 它的左、右子树也分别为二叉排序数（递归定义）

> 二叉排序树组织数据时，用于查找是比较方便的，因为每次经过一次节点时，最多可以减少一半的可能，不过极端情况会出现所有节点都位于同一侧，直观上看就是一条直线，那么这种查询的效率就比较低了，因此需要对二叉树左右子树的高度进行平衡化处理，于是就有了平衡二叉树（Balenced Binary Tree）。

所谓“平衡”，说的是这棵树的各个分支的高度是均匀的，它的左子树和右子树的高度之差绝对值小于1，这样就不会出现一条支路特别长的情况。于是，在这样的平衡树中进行查找时，总共比较节点的次数不超过树的高度，这就确保了查询的效率（时间复杂度为O(logn)）

### AVL树

> 平衡二叉树，一般是用平衡因子差值决定并通过旋转来实现，左右子树树高差不超过1，那么和红黑树比较它是严格的平衡二叉树，平衡条件非常严格（树高差只有1），只要插入或删除不满足上面的条件就要通过旋转来保持平衡。由于旋转是非常耗费时间的。
>
> AVL树内部是有序的。
>
> 深度是Olog(n)

适合用于插入删除次数比较少，但查找多的情况

----

应用相对其他数据结构比较少。windows对进程地址空间的管理用到了AVL树。Windows内核通过AVL树来保存一些离散的地址空间. 原因可能是訪问次数多于插入删除的次数。AVL树的高度较低于红黑树等

### 红黑树

> 平衡二叉树，通过对任何一条从根到叶子的简单路径上各个节点的颜色进行约束，确保没有一条路径会比其他路径长2倍，因而是近似平衡的。所以相对于严格要求平衡的AVL树来说，它的旋转保持平衡次数较少。
>
> 内部是有序的。主要用在数据库或者大型索引数据中

用于搜索时，插入删除次数多的情况下我们就用红黑树来取代AVL。

---

-  广泛用在C++的STL中。map和set都是用红黑树实现的
-  著名的linux进程调度[Completely Fair Scheduler](https://en.wikipedia.org/wiki/Completely_Fair_Scheduler),用红黑树管理**进程控制块**
-  **epoll**在内核中的实现，用红黑树管理事件块
-  **nginx**中，用红黑树管理timer等
-  Java的TreeMap实现

### B树B+树

> 主要用在数据库或者大型索引数据中，它们特点是一样的，是多路查找树，一般用于数据库中做索引，因为它们分支多层数少，因为磁盘IO是非常耗时的，而像大量数据存储在磁盘中所以我们要有效的减少磁盘IO次数避免磁盘频繁的查找。
>
> B+树是B树的变种树，有n棵子树的节点中含有n个关键字，每个关键字不保存数据，只用来索引，数据都保存在叶子节点。是为文件系统而生的。
>
> B+树相对B树磁盘读写代价更低：因为B+树非叶子结点只存储键值，单个节点占空间小，索引块能够存储更多的节点，从磁盘读索引时所需的索引块更少，所以索引查找时I/O次数较B-Tree索引少，效率更高。而且B+Tree在叶子节点存放的记录以链表的形式链接，**范围查找或遍历效率更高**。Mysql InnoDB用的就是B+Tree索引。

---

- B树一般用在数据库等大型索引。主要原因就是层数少，重点—>降低避免磁盘IO 
- B+树适应文件系统，想下文件系统的样子。文件夹并不保存文件仅仅有底层叶子节点保存数据。

### Trie树

> 又名单词查找树，一种树形结构，常用来操作字符串。它是**不同字符串的相同前缀只保存一份**。相对直接保存字符串肯定是节省空间的，但是它保存大量字符串时会很耗费内存（是内存）。
>
> 类似的有：前缀树(prefix tree)，后缀树(suffix tree)，radix tree(patricia tree, **compactprefix tree**)，crit-bit tree（解决耗费内存问题），以及前面说的double array trie。
> 前缀树：字符串快速检索，字符串排序，最长公共前缀，自动匹配前缀显示后缀。
> 后缀树：查找字符串s1在s2中，字符串s1在s2中出现的次数，字符串s1,s2最长公共部分，最长回文串。

---

- 前缀匹配，当输入时，搜索引擎会给予提示   --前缀树
- IP选路，也是前缀匹配，一定程度会用到trie。--radix树
- linux内核内存管理         --radix树

### 栈



### 优先队列



## 集合

### Set



### List





### Map





## 排序

### 冒泡排序



### 快速排序





### 归并排序





### 堆排序





## 查询



