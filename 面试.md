## mybatis

### mybatis缓存机制

mybatis提供了缓存机制减轻数据库压力，提高数据库性能

查询缓存分为一级缓存和二级缓存

mybatis默认只开启一级缓存

一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效

二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的

#### 一级缓存

mybatis的一级缓存是SqlSession级别的缓存，在操作数据库的时候需要先创建SqlSession会话对象，在对象中有一个HashMap用于存储缓存数据，此HashMap是当前会话对象私有的，别的SqlSession会话对象无法访问。

**流程：** 

1. 第一次执行select完毕会将查到的数据写入SqlSession内的HashMap中缓存起来
2. 第二次执行select会从缓存中查数据，如果select相同切传参数一样，那么就能从缓存中返回数据，不用去数据库了，从而提高了效率

**注意：**  

1. 如果SqlSession执行了DML操作（insert、update、delete），并commit了，那么mybatis就会清空当前SqlSession缓存中的所有缓存数据，这样可以保证缓存中的存的数据永远和数据库中一致，避免出现脏读
2. 当一个SqlSession结束后那么他里面的一级缓存也就不存在了，mybatis默认是开启一级缓存，不需要配置
3. mybatis的缓存是基于[namespace:sql语句:参数]来进行缓存的，意思就是，SqlSession的HashMap存储缓存数据时，是使用[namespace:sql:参数]作为key，查询返回的语句作为value保存的。

#### 二级缓存

二级缓存是mapper级别的缓存，也就是同一个namespace的mappe.xml，当多个SqlSession使用同一个Mapper操作数据库的时候，得到的数据会缓存在同一个二级缓存区域

二级缓存默认是没有开启的。需要在setting全局参数中配置开启二级缓存  在conf.xml：

```
<settings>
        <setting name="cacheEnabled" value="true"/><!--默认是false：关闭二级缓存-->
<settings>
```

在xxxMapper.xml中配置：

```
<cache eviction="LRU" flushInterval="60000" size="512" readOnly="true"/><!--当前mapper下所有语句开启二级缓存-->
```

表示: 配置了一个LRU缓存，并每隔60秒刷新，最大存储512个对象，而却返回的对象是只读的

参数含义：

- flushInterval       刷新间隔，可以被设置为任意的正整数，代表一个合理的毫秒形式的时间段。默认情况是不设置，即没有刷新间隔，缓存仅仅调用语句时刷新
- size     引用数目缓存的对象数目和运行环境的可用内存资源数目，默认值1024
- readOnly    只读 ，只读的缓存会给所有调用者返回缓存对象的相同实例。
- evivtion    回收策略，默认为LRU.常用的策略有：
  - LRU   - 最近最少使用的： 移除最长时间不被使用的对象
  - FIFO   - 先进先出：按对象进入缓存的顺序来移除它们
  - SOFT  - 软引用：移除基于垃圾回收器状态和软引用规则的对象
  - WEAK  - 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象

**流程：**

1. 当一个sqlseesion执行了一次select后，在关闭此session的时候，会将查询结果缓存到二级缓存
2. 当另一个sqlsession执行select时，首先会在他自己的一级缓存中找，如果没找到，就回去二级缓存中找，找到了就返回，就不用去数据库了，从而减少了数据库压力提高了性能　

**注意：**

1. 如果SqlSession执行了DML操作（insert、update、delete），并commit了，那么mybatis就会清空当前mapper缓存中的所有缓存数据，这样可以保证缓存中的存的数据永远和数据库中一致，避免出现脏读
2. mybatis的缓存是基于[namespace:sql语句:参数]来进行缓存的，意思就是，SqlSession的HashMap存储缓存数据时，是使用[namespace:sql:参数]作为key，查询返回的语句作为value保存的。

> 使用二级缓存时，与查询结果映射的java对象必须实现java.io.Serializable接口的序列化和反序列化操作，如果存在父类，其成员都需要实现序列化接口，实现序列化接口是为了对缓存数据进行序列化和反序列化操作，因为二级缓存数据存储介质多种多样，不一定在内存，有可能是硬盘或者远程服务器。

#### hiberante的缓存

Hibernate中提供了两级缓存，一级缓存是Session级别的缓存，它属于事务范围的缓存，该级缓存由hibernate管理，应用程序无需干预；二级缓存是SessionFactory级别的缓存，该级缓存可以进行配置和更改，并且可以动态加载和卸载，hibernate还为查询结果提供了一个查询缓存，它依赖于二级缓存

#### 缓存概念

缓存是位于应用程序和永久性数据存储源之间用于临时存放复制数据的内存区域，缓存可以降低应用程序之间读写永久性数据存储源的次数，从而提高应用程序的运行性能。

参考[计算机缓存结构](https://blog.csdn.net/hujutaoseu/article/details/56842762)

缓存范围决定了缓存的生命周期，缓存范围分为3类：

1. 事务范围：

   缓存只能被当前事务访问，缓存的生命周期依赖于事务的生命周期，事务结束时，缓存的生命周期也结束了；

2. 进程范围：

   缓存被进程内的所有事务共享，这些事务会并发访问缓存，需要对缓存采用必要的事务隔离机制，缓存的生命周期取决与进程的生命周期，进程结束，缓存的生命周期也结束了；

3. 集群范围：

   缓存被一个或多个计算机的进程共享，缓存中的数据被复制到集群中的每个进行节点，进程间通过远程通信来保证缓存中数据的一致性；

   在查询时，如果在事务范围内的缓存中没有找到，可以到进程范围或集群范围的缓存中查找，如果还没找到，则到数据库中查询；

## Redis

### redis的使用场景

redis最常用的物种数据格式：   1.String   2.Hash   3.List   4.Set   5.Sorted set  

1. String 

   | 常用命令          | 应用场景                                   |
   | ------------- | -------------------------------------- |
   | set、get       | 最简单的数据缓存                               |
   | mset、mget     | 批量操作，把数据统一传回客户端，节省网络io时间               |
   | decr、incr     | 计数器                                    |
   | append        | 可以作为时间序列，配合getrange、setrange,对字符串进行操作， |
   | setbit、getbit | 可以作为简单的布尔过滤器来判断用户是否执行过某些操作             |

2. List

   | 常用命令        | 应用场景        |
   | ----------- | ----------- |
   | lpush、lpop  | 队列操作，实现队列任务 |
   | lpush、ltrim | 显示最新的数据     |

3. Hash

   | 常用命令                | 应用场景                                     |
   | ------------------- | ---------------------------------------- |
   | hget、hset           | 实现一个key对应一个数据集集合，数据集集合里包含多个单独的key/value，操作依然是原子性的 |
   | hmget、hmset、hgetall | 批量操作，节省网络io时间                            |
   | hincrby             | 对哈希里域值，进行原子性加1                           |

4. Set

   | 常用命令                | 应用场景            |
   | ------------------- | --------------- |
   | sadd                | 存储一个不重复的数据      |
   | sunion、sdiff、sinter | 进行集合处理，并集、交集、差集 |

5. Sorted Set

   | 常用命令                 | 应用场景                      |
   | -------------------- | ------------------------- |
   | zadd                 | 存储一个按照score排序的数据集合，添加自动排序 |
   | zrange、zrangebyscore | 按照score顺序获取数据集            |
   | zrank                | 排行榜功能                     |

常见使用场景：

- 会话缓存（Session cache） redis提供持久化。

- 热数据缓存

- 全页缓存(FPC)   极大的提高网页的响应速率

- 队列   相当于消息系统，ActiveMQ，RocketMQ等工具类似；队列不仅可以把并发请求变成串行，并且还可以做队列或者栈使用

- 排行榜/计数器   Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单；诸如统计点击数等应用。由于单线程，可以避免并发问题，保证不会出错，而且100%毫秒级性能！

- 发布/订阅功能

- 位操作   用于数据量上亿的场景下。

  redis内构建一个足够长的数组，每个数组元素只能是0和1两个值，然后这个数组的下标index用来表示我们上面例子里面的用户id（必须是数字哈），那么很显然，这个几亿长的大数组就能通过下标和元素值（0和1）来构建一个记忆系统

- 分布式锁与单线程机制

  - 验证前端的重复请求，可以通过redis进行过滤：每次请求将request ip、参数、接口等hash作为key存储redis(幂等性请求)。设置多长时间有效期，然后下次请求过来的时候先在redis中检索有没有这个key，进而验证是不是一定时间内过来的重复请求
  - 秒杀系统，基于redis是单线程特征，防止出现数据库爆破
  - 全局增量ID 生成


## Error与Exception

Error类和Exception类的父类都是throwable类。

- Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。
- Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。

#### CheckedException与RuntimeEception的区别

- 运行时异常（Runtime Exception）

  > 运行时异常;ArithmaticException,IllegalArgumentException，编译能通过，但是一运行就终止了，程序不会处理运行时异常，出现这类异常，程序会终止。

- 受检查的异常(Checked Exception )

  > 受检查的异常，要么用try。。。catch捕获，要么用throws字句声明抛出，交给它的父类处理，否则编译不会通过。

## 反射

#### Class.forName和ClassLoader区别

java中class.forName()和classLoader都可用来对类进行加载。

- class.forName()前者除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。
- classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。

Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象。如果程序依赖于Class是否被初始化，就必须用Class.forName(name)了。

## JVM相关

#### 什么情况下会发生栈内存溢出？

一般情况下有两种栈溢出情况：

- 如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量的时候，java虚拟机将抛出一个StackOverFlowError异常。
- 如果java虚拟机栈可以动态拓展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成拓展，或者在建立新线程的时候没有足够的内存去创建对应的虚拟机栈，那java虚拟机将会抛出一个OutOfMemoryError异常。

## 泛型

#### 泛型概念

泛型（Generic type 或者 generics）是对 Java 语言的类型系统的一种扩展，以支持创建可以按类型进行参数化的类。可以把类型参数看作是使用参数化类型时指定的类型的一个占位符，就像方法的形式参数是运行时传递的值的占位符一样。

*泛型还有一种较为准确的说法就是为了参数化类型，或者说可以将类型当作参数传递给一个类或者是方法。*

*泛型就是对参数类型的增强。允许一些自定义类型作为泛型的参数类型*

好处：

1. 类型安全。 泛型的主要目标是提高 Java 程序的类型安全。
2. 消除强制类型转换。
3. 潜在的性能收益。

泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做**类型擦除。**

> 泛型类或者泛型方法中，不接受 8 种基本数据类型

## Java基础

#### 如何从一个static方法对非static方法进行调用

#### java中如何跳出当前的多重嵌套循环

#### java中如何实现动态数组





## JavaWeb

#### web.xml配置文件

参考: 1.   [web.xml配置](https://www.jianshu.com/p/bdf19d50a723)

2.   [web.xml元素](http://www.cnblogs.com/hafiz/p/5715523.html)

#### tomcat处理一个Http请求过程

*假设请求地址   http://localhost:8080/wsota/wsota_index.jsp*

1. 请求被发送到本机端口8080，被在那里侦听的Coyote HTTP/1.1 Connector获得
2. Connector把该请求交给它所在的Service的Engine来处理，并等待来自Engine的回应
3. Engine获得请求localhost/wsota/wsota_index.jsp，匹配它所拥有的所有虚拟主机Host
4. Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机）
5. localhost Host获得请求/wsota/wsota_index.jsp，匹配它所拥有的所有Context
6. Host匹配到路径为/wsota的Context（如果匹配不到就把该请求交给路径名为”"的Context去处理）
7. path=”/wsota”的Context获得请求/wsota_index.jsp，在它的mapping table中寻找对应的servlet
8. Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类
9. 构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法
10. Context把执行完了之后的HttpServletResponse对象返回给Host
11. Host把HttpServletResponse对象返回给Engine
12. Engine把HttpServletResponse对象返回给Connector
13. Connector把HttpServletResponse对象返回给客户browser

#### Tomcat启动过程

通过bin目录下的startup.bat来启动tomcat，startup.bat又调用了catalina.bat，catalina.bat从命令行启动org.apache.catalina.startup.Bootstrap，这个类有main方法，所以可以从命令行执行。

Bootstrap执行后，首先执行init()方法进行初始化，然后调用load()和start()方法。下面具体介绍init()方法、load()、start()方法

1. init()

   首先设置catalina.home，catalina.base这两个环境变量；

   创建了三个类加载器

   根据conf/catalina.properties中的配置，初始化了三个ClassLoader：commonLoader、catalinaLoader、sharedLoader；并且把catalinaLoader设置为当前线程上下文的类加载器；然后创建Catalina类的对象（变量名是catalinaDaemon）：

   ```
   Class startupClass =catalinaLoader.loadClass ("org.apache.catalina.startup.Catalina");
   Object startupInstance = startupClass.newInstance();
   ```

2. load()

   通过反射机制，调用catalina对象的load()方法------在该方法中，初始化一些目录，比如temp目录，初始化名称空间，如java:env；然后使用Digester的方式，根据server.xml的配置来装配tomcat的各个组件，这里暂时提一下tomcat的结构，tomcat顶层组件是Server，Server下面有多个Service组件，还有Connector、Engin、Host等。装配组件的过程中，生成了各个组件的对象，并设置了他们之间的关联关系。

3. start()

   该方法里面，通过反射机制，调用了Catalina对象的start()方法。Catalina对象的start()方法又调用了Server对象的Start()方法，并设置关闭Server的回调方法。

#### JVM类加载过程

当jvm运行时，需要加载某些类：（父类委托机制）

1.  用户自己的类加载器，把加载请求传给父加载器，父加载器再传给其父加载器，一直到加载器树的顶层。
2.  最顶层的类加载器首先针对其特定的位置加载，如果加载不到就转交给子类。
3. 如果一直到底层的类加载都没有加载到，那么就会抛出异常ClassNotFoundException。

#### Tocmat类加载过程

web应用加载类：

1. 使用bootstrap引导类加载器加载


2. 使用system系统类加载器加载
3. 使用应用类加载器在WEB-INF/classes中加载
4. 使用应用类加载器在WEB-INF/lib中加载
5. 使用common类加载器在CATALINA_HOME/lib中加载

## SQL

#### 如何让sql使用指定的索引

select * from tabel with(指定索引名)

或  select * from tabel with(INDEX =指定索引名)

#### 位图索引

**位图索引**是一种使用[位图](https://baike.so.com/doc/630856-667651.html)的特殊数据库索引。

主要针对大量相同值的列而创建(例如:类别，操作员，部门ID,库房ID等),索引块的一个索引行中存储键值和起止Rowid,以及这些键值的位置编码,

位置编码中的每一位表示键值对应的数据行的有无.一个块可能指向的是几十甚至成百上千行数据的位置.这种方式存储数据,相对于B*Tree索引,占用的空间非常小,创建和使用非常快.

当根据键值查询时,可以根据起始Rowid和位图状态,快速定位数据.

当根据键值做and,or或 in(x,y,..)查询时,直接用索引的[位图](https://baike.so.com/doc/630856-667651.html)进行或运算,快速得出结果行数据.

当select count(XX) 时,可以直接访问索引就快速得出统计数据.

```
创建语法
create bitmap index ssex_bitmap_index on zhou.student(ssex) 
tablespace MYSPACE; 
```

##### 位图索引的优势和不适合使用的场景

优势：

1. 位图索引使用于低基数的列，相对于B树索引，它的count,and,or操作更有效
2. 位图索引存放的是0,1的比特位，相对于B树索引，占字节数特别少?

不适用场景：

1. 列的基数比较多，不适合位图索引，因为它会占用更多的存储空间
2. 索引列DML频繁的列，不适合位图索引，容易造成死锁?

## 网络编程

#### TCP/IP

TCP/IP是个协议组，可分为三个层次：网络层、传输层和应用层。 
在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。 
在传输层中有TCP协议与UDP协议。 
在应用层有:TCP包括FTP、HTTP、TELNET、SMTP等协议 
​                    UDP包括DNS、TFTP等协议 

**Socket**

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

#### socket长连接和短连接区别

概念：长连接与短连接的概念：前者是整个通讯过程，客户端和服务端只用一个Socket对象，长期保持Socket的连接；后者是每次请求，都新建一个Socket,处理完一个请求就直接关闭掉Socket。所以，其实区分长短连接就是：整个客户和服务端的通讯过程是利用一个Socket还是多个Socket进行的。

**短连接**

连接->传输数据->关闭连接 
HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。 
也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。 

**长连接 **
连接->传输数据->保持连接 -> 传输数据-> 。。。 ->关闭连接。 
长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。 

> **http的长连接**
> HTTP也可以建立长连接的，使用Connection:keep-alive，HTTP 1.1默认进行持久连接。HTTP1.1和HTTP1.0相比较而言，最大的区别就是增加了持久连接支持(貌似最新的 http1.0 可以显示的指定 keep-alive),但还是无状态的，或者说是不可以信任的。 

#### socket异步与同步区别

**1、异步 **
报文发送和接收是分开的，相互独立的，互不影响。这种方式又分两种情况： 

- 异步双工：接收和发送在同一个程序中，由两个不同的子进程分别负责发送和接收 
- 异步单工：接收和发送是用两个不同的程序来完成。 

**2、同步 **
报文发送和接收是同步进行，即报文发送后等待接收返回报文。 同步方式一般需要考虑超时问题，即报文发出去后不能无限等待，需要设定超时时间，超过该时间发送方不再等待读返回报文，直接通知超时返回。

#### 单工、半双工和全双工

根据通信双方的分工和信号传输方向可将通信分为三种方式：单工、半双工与全双工。在计算机网络中主要采用双工方式，其中：局域网采用半双工方式，城域网和广域网采用全双工方式。

- 单工(Simplex)方式：通信双方设备中发送器与接收器分工明确，只能在由发送器向接收器的单一固定方向上传送数据。采用单工通信的典型发送设备如早期计算机的读卡器，典型的接收设备如打印机。
- 半双工(Half Duplex)方式：通信双方设备既是发送器，也是接收器，两台设备可以相互传送数据，但某一时刻则只能向一个方向传送数据。例如，步话机是半双工设备，因为在一个时刻只能有一方说话。
- 全双工(Full Duplex)方式：通信双方设备既是发送器，也是接收器，两台设备可以同时在两个方向上传送数据。例如，电话是全双工设备，因为双方可同时说话。

## Spring

#### Spring声明式事务

Spring声明式事务管理，通过Spring AOP实现声明式事务管理

事务的四种属性

1. **事务的传播方式**

> 事务传播行为：是指添加事物时的策略

- PROPAGATION_REQUIRED   如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。
- PROPAGATION_SUPPORTS    支持当前事务，如果当前没有事务，就以非事务方式执行。
- PROPAGATION_MANDATORY   使用当前的事务，如果当前没有事务，就抛出异常。
- PROPAGATION_REQUIRES_NEW   新建事务，如果当前存在事务，把当前事务挂起。
- PROPAGATION_NOT_SUPPORTED     以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
- PROPAGATION_NEVER     以非事务方式执行，如果当前存在事务，则抛出异常。
- PROPAGATION_NESTED   如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。

2. **事务隔离级别**

- ISOLATION_DEFAULT：用底层数据库的默认隔离级别
- ISOLATION_READ_UNCOMMITTED（未提交读）：最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）
- ISOLATION_READ_COMMITTED（提交读）：一个事务提交后才能被其他事务读取到（该隔离级别禁止其他事务读取到未提交事务的数据、所以还是会造成幻读、不可重复读）、sql server默认级别
- ISOLATION_REPEATABLE_READ（可重复读）：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（该隔离基本可防止脏读，不可重复读（重点在修改），但会出现幻读（重点在增加与删除））（MySql默认级别，更改可通过set transaction isolation level 级别）
- ISOLATION_SERIALIZABLE（序列化）：代价最高最可靠的隔离级别（该隔离级别能防止脏读、不可重复读、幻读）

>其他概念：
>
>- 丢失更新：两个事务同时更新一行数据，最后一个事务的更新会覆盖掉第一个事务的更新，从而导致第一个事务更新的数据丢失，这是由于没有加锁造成的；
>- 幻读：同样的事务操作过程中，不同时间段多次（不同事务）读取同一数据，读取到的内容不一致（一般是行数变多或变少）。
>- 脏读：一个事务读取到另外一个未提及事务的内容，即为脏读。
>- 不可重复读：同一事务中，多次读取内容不一致（一般行数不变，而内容变了）。

数据库隔离级别越高，执行代价越高，并发执行能力越差，因此在实际项目开发使用时要综合考虑，为了考虑并发性能一般使用提交读隔离级别，它能避免丢失更新和脏读。

3. 事务的超时值
4. 事务的只读标志

