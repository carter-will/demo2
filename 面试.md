[TOC]

## mybatis

### mybatis缓存机制

mybatis提供了缓存机制减轻数据库压力，提高数据库性能

查询缓存分为一级缓存和二级缓存

mybatis默认只开启一级缓存

一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效

二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的

#### 一级缓存

mybatis的一级缓存是SqlSession级别的缓存，在操作数据库的时候需要先创建SqlSession会话对象，在对象中有一个HashMap用于存储缓存数据，此HashMap是当前会话对象私有的，别的SqlSession会话对象无法访问。

**流程：** 

1. 第一次执行select完毕会将查到的数据写入SqlSession内的HashMap中缓存起来
2. 第二次执行select会从缓存中查数据，如果select相同切传参数一样，那么就能从缓存中返回数据，不用去数据库了，从而提高了效率

**注意：**  

1. 如果SqlSession执行了DML操作（insert、update、delete），并commit了，那么mybatis就会清空当前SqlSession缓存中的所有缓存数据，这样可以保证缓存中的存的数据永远和数据库中一致，避免出现脏读
2. 当一个SqlSession结束后那么他里面的一级缓存也就不存在了，mybatis默认是开启一级缓存，不需要配置
3. mybatis的缓存是基于[namespace:sql语句:参数]来进行缓存的，意思就是，SqlSession的HashMap存储缓存数据时，是使用[namespace:sql:参数]作为key，查询返回的语句作为value保存的。

#### 二级缓存

二级缓存是mapper级别的缓存，也就是同一个namespace的mappe.xml，当多个SqlSession使用同一个Mapper操作数据库的时候，得到的数据会缓存在同一个二级缓存区域

二级缓存默认是没有开启的。需要在setting全局参数中配置开启二级缓存  在conf.xml：

```
<settings>
        <setting name="cacheEnabled" value="true"/><!--默认是false：关闭二级缓存-->
<settings>
```

在xxxMapper.xml中配置：

```
<cache eviction="LRU" flushInterval="60000" size="512" readOnly="true"/><!--当前mapper下所有语句开启二级缓存-->
```

表示: 配置了一个LRU缓存，并每隔60秒刷新，最大存储512个对象，而却返回的对象是只读的

参数含义：

- flushInterval       刷新间隔，可以被设置为任意的正整数，代表一个合理的毫秒形式的时间段。默认情况是不设置，即没有刷新间隔，缓存仅仅调用语句时刷新
- size     引用数目缓存的对象数目和运行环境的可用内存资源数目，默认值1024
- readOnly    只读 ，只读的缓存会给所有调用者返回缓存对象的相同实例。
- evivtion    回收策略，默认为LRU.常用的策略有：
  - LRU   - 最近最少使用的： 移除最长时间不被使用的对象
  - FIFO   - 先进先出：按对象进入缓存的顺序来移除它们
  - SOFT  - 软引用：移除基于垃圾回收器状态和软引用规则的对象
  - WEAK  - 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象

**流程：**

1. 当一个sqlseesion执行了一次select后，在关闭此session的时候，会将查询结果缓存到二级缓存
2. 当另一个sqlsession执行select时，首先会在他自己的一级缓存中找，如果没找到，就回去二级缓存中找，找到了就返回，就不用去数据库了，从而减少了数据库压力提高了性能　

**注意：**

1. 如果SqlSession执行了DML操作（insert、update、delete），并commit了，那么mybatis就会清空当前mapper缓存中的所有缓存数据，这样可以保证缓存中的存的数据永远和数据库中一致，避免出现脏读
2. mybatis的缓存是基于[namespace:sql语句:参数]来进行缓存的，意思就是，SqlSession的HashMap存储缓存数据时，是使用[namespace:sql:参数]作为key，查询返回的语句作为value保存的。

> 使用二级缓存时，与查询结果映射的java对象必须实现java.io.Serializable接口的序列化和反序列化操作，如果存在父类，其成员都需要实现序列化接口，实现序列化接口是为了对缓存数据进行序列化和反序列化操作，因为二级缓存数据存储介质多种多样，不一定在内存，有可能是硬盘或者远程服务器。

#### hiberante的缓存

Hibernate中提供了两级缓存，一级缓存是Session级别的缓存，它属于事务范围的缓存，该级缓存由hibernate管理，应用程序无需干预；二级缓存是SessionFactory级别的缓存，该级缓存可以进行配置和更改，并且可以动态加载和卸载，hibernate还为查询结果提供了一个查询缓存，它依赖于二级缓存

#### 缓存概念

缓存是位于应用程序和永久性数据存储源之间用于临时存放复制数据的内存区域，缓存可以降低应用程序之间读写永久性数据存储源的次数，从而提高应用程序的运行性能。

参考[计算机缓存结构](https://blog.csdn.net/hujutaoseu/article/details/56842762)

缓存范围决定了缓存的生命周期，缓存范围分为3类：

1. 事务范围：

   缓存只能被当前事务访问，缓存的生命周期依赖于事务的生命周期，事务结束时，缓存的生命周期也结束了；

2. 进程范围：

   缓存被进程内的所有事务共享，这些事务会并发访问缓存，需要对缓存采用必要的事务隔离机制，缓存的生命周期取决与进程的生命周期，进程结束，缓存的生命周期也结束了；

3. 集群范围：

   缓存被一个或多个计算机的进程共享，缓存中的数据被复制到集群中的每个进行节点，进程间通过远程通信来保证缓存中数据的一致性；

   在查询时，如果在事务范围内的缓存中没有找到，可以到进程范围或集群范围的缓存中查找，如果还没找到，则到数据库中查询；

## 缓存

### 缓存穿透、缓存并发、缓存失效、缓存雪崩

**缓存穿透**

缓存穿透指的是使用不存在的key进行大量的高并发查询，这导致缓存无法命中，每次请求都要穿透到后端数据库系统进行查询，使数据库压力过大，甚至使数据库服务被压死。

​:arrow_forward: 我们通常将空值缓存起来，再次接收到同样的查询请求时，若命中缓存并且值为空，就会直接返回，不会透传到数据库，避免缓存穿透。

(如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。)

:arrow_forward:采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

**缓存并发**

缓存并发的问题通常发生在高并发的场景下，当一个缓存key过期时，因为访问这个缓存key 的请求量较大，多个请求同时发现缓存过期，因此多个请求会同时访问数据库来查询最新数据，并且回写缓存，这样会造成应用和数据库的负载增加，性能降低，由于并发较高，甚至会导致数据库被压死。

​:arrow_forward: **分布式锁** 使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。这种情况和刚才说的预先设定值问题有些类似，只不过利用锁的方式，会造成部分请求等待。

:arrow_forward:**本地锁** 与分布式锁类似，我们通过本地锁的方式来限制只有一个线程去数据库中查询数据，而其他线程只需等待，等前面的线程查询到数据后再访问缓存。但是，这种方法只能限制一个服务节点只有一个线程去数据库中查询，如果一个服务有多个节点，则还会有多个数据库查询操作，也就是说在节点数量较多的情况下并没有完全解决缓存并发的问题。

:arrow_forward:**软过期** 软过期指对缓存中的数据设置失效时间，就是不使用缓存服务提供的过期时间，而是业务层在数据中存储过期时间信息，由业务程序判断是否过期并更新，在发现了数据即将过期时，将缓存的时效延长，程序可以派遣一个线程去数据库中获取最新的数据，其他线程这时看到延长了的过期时间，就会继续使用旧数据，等派遣的线程获取最新数据后再更新缓存。

*也可以通过异步更新服务来更新设置软过期的缓存，这样应用层就不用关心缓存并发的问题了。*

**缓存失效**

引起这个问题的主要原因还是高并发的时候，平时我们设定一个缓存的过期时间时，可能有一些会设置1分钟啊，5分钟这些，并发很高时可能会出在某一个时间同时生成了很多的缓存，并且过期时间都一样，这个时候就可能引发一当过期时间到后，这些缓存同时失效，请求全部转发到DB，DB可能会压力过重。

​:arrow_forward: 将缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。 

:arrow_forward:分析用户行为，尽量让失效时间点均匀分布

**缓存雪崩**

缓存雪崩指缓存服务器重启或者大量缓存集中在某一个时间段内失效，给后端数据库造成瞬时的负载升高的压力，甚至压垮数据库的情况。

当发生大量的缓存穿透，例如对某个失效的缓存的大并发访问就造成了缓存雪崩。

​:arrow_forward: 对不同的数据使用不同的失效时间，甚至对相同的数据、不同的请求使用不同的失效时间.

:arrow_forward:考虑用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，避免缓存失效时对数据库造成太大的压力，虽然能够在一定的程度上缓解了数据库的压力但是与此同时又降低了系统的吞吐量。

:arrow_forward:如果是因为某台缓存服务器宕机，可以考虑做主备

**缓存预热**

存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！

实现思路：

1. 直接写个缓存刷新页面，上线时手工操作下；
2. 数据量不大，可以在项目启动的时候自动进行加载；
3. 定时刷新缓存。

**缓存更新**

 除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：

- 定时去清理过期的缓存；
- 当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。

> 第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！

**缓存降级**

 当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。

降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的。

​:bang:  在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：

- 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；
- 警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；
- 错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；
- 严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。

### 缓存算法

- FIFO算法：First in First out，先进先出。原则：一个数据最先进入缓存中，则应该最早淘汰掉。也就是说，当缓存满的时候，应当把最先进入缓存的数据给淘汰掉。
- LFU算法：Least Frequently Used，最不经常使用算法。
- LRU算法：Least Recently Used，近期最少使用算法。

> LRU和LFU的区别。LFU算法是根据在一段时间里数据项被使用的次数选择出最少使用的数据项，即根据使用次数的差异来决定。而LRU是根据使用时间的差异来决定的

### 缓存热点key问题

**问题**  我们通常使用 缓存 + 过期时间的策略来帮助我们加速接口的访问速度，减少了后端负载，同时保证功能的更新。但有两个问题如果同时出现，可能就会对系统造成致命的危害：

- 这个key是一个热点key
- 缓存的构建是需要一定时间的。

会有一个致命问题：在缓存失效的瞬间，有大量线程来构建缓存，造成后端负载加大，甚至可能会让系统崩溃 。

解决方案：

1. 使用互斥锁(mutex key)

   种解决方案思路比较简单，就是只让一个线程构建缓存，其他线程等待构建缓存的线程执行完，重新从缓存获取数据就可以了. 如果是单机，可以用synchronized或者lock来处理，如果是分布式环境可以用分布式锁就可以了（分布式锁，可以用memcache的add, redis的setnx, zookeeper的添加节点操作）。

   redis代码示例：

   ```
   public String get(key) {  
         String value = redis.get(key);  
         if (value == null) { //代表缓存值过期  
             //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db  
             if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {  //代表设置成功  
                  value = db.get(key);  
                         redis.set(key, value, expire_secs);  
                         redis.del(key_mutex);  
                 } else {  //这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可  
                         sleep(50);  
                         get(key);  //重试  
                 }  
             } else {  
                 return value;        
             }  
    }  
   ```

2.  "提前"使用互斥锁(mutex key)

   在value内部设置1个超时值(timeout1), timeout1比实际的memcache timeout(timeout2)小。当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache。然后再从数据库加载数据并设置到cache中。伪代码如下：

   ```
   v = memcache.get(key);    
   if (v == null) {    
       if (memcache.add(key_mutex, 3 * 60 * 1000) == true) {    
           value = db.get(key);    
           memcache.set(key, value);    
           memcache.delete(key_mutex);    
       } else {    
           sleep(50);    
           retry();    
       }    
   } else {    
       if (v.timeout <= now()) {    
           if (memcache.add(key_mutex, 3 * 60 * 1000) == true) {    
               // extend the timeout for other threads    
               v.timeout += 3 * 60 * 1000;    
               memcache.set(key, v, KEY_TIMEOUT * 2);    
               // load the latest value from db    
               v = db.get(key);    
               v.timeout = KEY_TIMEOUT;    
               memcache.set(key, value, KEY_TIMEOUT * 2);    
               memcache.delete(key_mutex);    
           } else {    
               sleep(50);    
               retry();    
           }    
       }    
   }
   ```

3. 永远不过期

   - 从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。
   - 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期

> 从实战看，这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。

```
String get(final String key) {    
        V v = redis.get(key);    
        String value = v.getValue();    
        long timeout = v.getTimeout();    
        if (v.timeout <= System.currentTimeMillis()) {    
            // 异步更新后台异常执行    
            threadPool.execute(new Runnable() {    
                public void run() {    
                    String keyMutex = "mutex:" + key;    
                    if (redis.setnx(keyMutex, "1")) {    
                        // 3 min timeout to avoid mutex holder crash    
                        redis.expire(keyMutex, 3 * 60);    
                        String dbValue = db.get(key);    
                        redis.set(key, dbValue);    
                        redis.delete(keyMutex);    
                    }    
                }    
            });    
        }    
        return value;    
}  
```

4. 资源保护

   采用netflix的hystrix，可以做资源的隔离保护主线程池，如果把这个应用到缓存的构建也未尝不可。

四中方式对比：

| 解决方案                | 优点                                       | 缺点                                       |
| ------------------- | ---------------------------------------- | ---------------------------------------- |
| 简单分布式互斥锁（mutex key） | 1.思路简单                        2.保证一直性    | 1.代码复杂度增大                                                                                                                                                     2.存在死锁的风险                                                                                                                                                                          3.  存在线程池阻塞 |
| “提前”使用互斥锁           | 保证一致性                                    | 同上                                       |
| 不过期                 | 异步构建缓存，不会阻塞线程池                           | 1.不保证一致性                                                                                                                                                           2.代码复杂度增大（每个value都要维护一个timekey）                                                                                                3.占用一定的内存空间（每个value都要维护一个timekey） |
| 资源隔离组件hystrix       | 1.hystrix技术成熟，有效保证后端                     2.hystrix监控强大 | 部分访问存在降级策略                               |

## Redis

### redis的使用场景

redis最常用的物种数据格式：   1.String   2.Hash   3.List   4.Set   5.Sorted set  

1. String 

   | 常用命令          | 应用场景                                   |
   | ------------- | -------------------------------------- |
   | set、get       | 最简单的数据缓存                               |
   | mset、mget     | 批量操作，把数据统一传回客户端，节省网络io时间               |
   | decr、incr     | 计数器                                    |
   | append        | 可以作为时间序列，配合getrange、setrange,对字符串进行操作， |
   | setbit、getbit | 可以作为简单的布尔过滤器来判断用户是否执行过某些操作             |

2. List

   | 常用命令        | 应用场景        |
   | ----------- | ----------- |
   | lpush、lpop  | 队列操作，实现队列任务 |
   | lpush、ltrim | 显示最新的数据     |

3. Hash

   | 常用命令                | 应用场景                                     |
   | ------------------- | ---------------------------------------- |
   | hget、hset           | 实现一个key对应一个数据集集合，数据集集合里包含多个单独的key/value，操作依然是原子性的 |
   | hmget、hmset、hgetall | 批量操作，节省网络io时间                            |
   | hincrby             | 对哈希里域值，进行原子性加1                           |

4. Set

   | 常用命令                | 应用场景            |
   | ------------------- | --------------- |
   | sadd                | 存储一个不重复的数据      |
   | sunion、sdiff、sinter | 进行集合处理，并集、交集、差集 |

5. Sorted Set

   | 常用命令                 | 应用场景                      |
   | -------------------- | ------------------------- |
   | zadd                 | 存储一个按照score排序的数据集合，添加自动排序 |
   | zrange、zrangebyscore | 按照score顺序获取数据集            |
   | zrank                | 排行榜功能                     |

常见使用场景：

- 会话缓存（Session cache） redis提供持久化。

- 热数据缓存

- 全页缓存(FPC)   极大的提高网页的响应速率

- 队列   相当于消息系统，ActiveMQ，RocketMQ等工具类似；队列不仅可以把并发请求变成串行，并且还可以做队列或者栈使用

- 排行榜/计数器   Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单；诸如统计点击数等应用。由于单线程，可以避免并发问题，保证不会出错，而且100%毫秒级性能！

- 发布/订阅功能

- 位操作   用于数据量上亿的场景下。

  redis内构建一个足够长的数组，每个数组元素只能是0和1两个值，然后这个数组的下标index用来表示我们上面例子里面的用户id（必须是数字哈），那么很显然，这个几亿长的大数组就能通过下标和元素值（0和1）来构建一个记忆系统

- 分布式锁与单线程机制

  - 验证前端的重复请求，可以通过redis进行过滤：每次请求将request ip、参数、接口等hash作为key存储redis(幂等性请求)。设置多长时间有效期，然后下次请求过来的时候先在redis中检索有没有这个key，进而验证是不是一定时间内过来的重复请求
  - 秒杀系统，基于redis是单线程特征，防止出现数据库爆破
  - 全局增量ID 生成


## Error与Exception

Error类和Exception类的父类都是throwable类。

- Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。
- Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。

#### CheckedException与RuntimeEception的区别

- 运行时异常（Runtime Exception）

  > 运行时异常;ArithmaticException,IllegalArgumentException，编译能通过，但是一运行就终止了，程序不会处理运行时异常，出现这类异常，程序会终止。

- 受检查的异常(Checked Exception )

  > 受检查的异常，要么用try。。。catch捕获，要么用throws字句声明抛出，交给它的父类处理，否则编译不会通过。

## 反射

#### Class.forName和ClassLoader区别

java中class.forName()和classLoader都可用来对类进行加载。

- class.forName()前者除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。
- classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。

Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象。如果程序依赖于Class是否被初始化，就必须用Class.forName(name)了。

## JVM相关

#### 什么情况下会发生栈内存溢出？

一般情况下有两种栈溢出情况：

- 如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量的时候，java虚拟机将抛出一个StackOverFlowError异常。
- 如果java虚拟机栈可以动态拓展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成拓展，或者在建立新线程的时候没有足够的内存去创建对应的虚拟机栈，那java虚拟机将会抛出一个OutOfMemoryError异常。

## 泛型

#### 泛型概念

泛型（Generic type 或者 generics）是对 Java 语言的类型系统的一种扩展，以支持创建可以按类型进行参数化的类。可以把类型参数看作是使用参数化类型时指定的类型的一个占位符，就像方法的形式参数是运行时传递的值的占位符一样。

*泛型还有一种较为准确的说法就是为了参数化类型，或者说可以将类型当作参数传递给一个类或者是方法。*

*泛型就是对参数类型的增强。允许一些自定义类型作为泛型的参数类型*

好处：

1. 类型安全。 泛型的主要目标是提高 Java 程序的类型安全。
2. 消除强制类型转换。
3. 潜在的性能收益。

泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做**类型擦除。**

> 泛型类或者泛型方法中，不接受 8 种基本数据类型

## Java基础

#### 如何从一个static方法对非static方法进行调用

​:a:  不可以在一个static方法内部发出对非static方法的调用；static方法是静态方法，是属于类的方法，非static方法是属于对象的方法。

所以在static方法中想要调用非static方法，要先新创建一个对象，再有这个对象来调用非static方法。

#### java中如何跳出当前的多重嵌套循环

​:a: 要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的的break语句，即可跳出

```
ok:
for(int i = 0;i<10;i++){
  for(int j = 0;j<10;j++){
    if(j == 5) break ok;
  }
}
```

#### java中如何实现动态数组

​:a: 当想增加数组大小时，就另开一个新的数组，把旧的数组放入其中即可

System.arraycopy(src, 0, dest, 0, src.length);    //关键方法

## JavaWeb

#### web.xml配置文件

参考: 1.   [web.xml配置](https://www.jianshu.com/p/bdf19d50a723)

2.   [web.xml元素](http://www.cnblogs.com/hafiz/p/5715523.html)

#### tomcat处理一个Http请求过程

*假设请求地址   http://localhost:8080/wsota/wsota_index.jsp*

1. 请求被发送到本机端口8080，被在那里侦听的Coyote HTTP/1.1 Connector获得
2. Connector把该请求交给它所在的Service的Engine来处理，并等待来自Engine的回应
3. Engine获得请求localhost/wsota/wsota_index.jsp，匹配它所拥有的所有虚拟主机Host
4. Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机）
5. localhost Host获得请求/wsota/wsota_index.jsp，匹配它所拥有的所有Context
6. Host匹配到路径为/wsota的Context（如果匹配不到就把该请求交给路径名为”"的Context去处理）
7. path=”/wsota”的Context获得请求/wsota_index.jsp，在它的mapping table中寻找对应的servlet
8. Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类
9. 构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法
10. Context把执行完了之后的HttpServletResponse对象返回给Host
11. Host把HttpServletResponse对象返回给Engine
12. Engine把HttpServletResponse对象返回给Connector
13. Connector把HttpServletResponse对象返回给客户browser

#### Tomcat启动过程

通过bin目录下的startup.bat来启动tomcat，startup.bat又调用了catalina.bat，catalina.bat从命令行启动org.apache.catalina.startup.Bootstrap，这个类有main方法，所以可以从命令行执行。

Bootstrap执行后，首先执行init()方法进行初始化，然后调用load()和start()方法。下面具体介绍init()方法、load()、start()方法

1. init()

   首先设置catalina.home，catalina.base这两个环境变量；

   创建了三个类加载器

   根据conf/catalina.properties中的配置，初始化了三个ClassLoader：commonLoader、catalinaLoader、sharedLoader；并且把catalinaLoader设置为当前线程上下文的类加载器；然后创建Catalina类的对象（变量名是catalinaDaemon）：

   ```
   Class startupClass =catalinaLoader.loadClass ("org.apache.catalina.startup.Catalina");
   Object startupInstance = startupClass.newInstance();
   ```

2. load()

   通过反射机制，调用catalina对象的load()方法------在该方法中，初始化一些目录，比如temp目录，初始化名称空间，如java:env；然后使用Digester的方式，根据server.xml的配置来装配tomcat的各个组件，这里暂时提一下tomcat的结构，tomcat顶层组件是Server，Server下面有多个Service组件，还有Connector、Engin、Host等。装配组件的过程中，生成了各个组件的对象，并设置了他们之间的关联关系。

3. start()

   该方法里面，通过反射机制，调用了Catalina对象的start()方法。Catalina对象的start()方法又调用了Server对象的Start()方法，并设置关闭Server的回调方法。

#### JVM类加载过程

当jvm运行时，需要加载某些类：（父类委托机制）

1.  用户自己的类加载器，把加载请求传给父加载器，父加载器再传给其父加载器，一直到加载器树的顶层。
2.  最顶层的类加载器首先针对其特定的位置加载，如果加载不到就转交给子类。
3.  如果一直到底层的类加载都没有加载到，那么就会抛出异常ClassNotFoundException。

#### Tocmat类加载过程

web应用加载类：

1. 使用bootstrap引导类加载器加载


2. 使用system系统类加载器加载
3. 使用应用类加载器在WEB-INF/classes中加载
4. 使用应用类加载器在WEB-INF/lib中加载
5. 使用common类加载器在CATALINA_HOME/lib中加载

#### 页面间对象传递的方法

JSP页面之间的七种传参方法

1. 利用javaBean
2. 绑定到session对象
3. 绑定到application
4. 绑定到request
5. 使用JSP动作指令传参
6. 表单传参
7. URL传参

#### JSP九大内置对象的主要方法

1. request对象

   客户端的请求信息被封装在request对象中，它是HttpServletRequest类的实例。

   1   object getAttribute(String name) 返回指定属性的属性值 
   2   Enumeration getAttributeNames() 返回所有可用属性名的枚举 
   3   String getCharacterEncoding() 返回字符编码方式 
   4   int getContentLength() 返回请求体的长度（以字节数） 
   5   String getContentType() 得到请求体的MIME类型 
   6   ServletInputStream getInputStream() 得到请求体中一行的二进制流 
   7   String getParameter(String name) 返回name指定参数的参数值 
   8   Enumeration getParameterNames() 返回可用参数名的枚举 
   9   String[] getParameterValues(String name) 返回包含参数name的所有值的数组 
   10   String getProtocol() 返回请求用的协议类型及版本号 
   11   String getScheme() 返回请求用的计划名,如:http.https及ftp等 
   12   String getServerName() 返回接受请求的服务器主机名 
   13   int getServerPort() 返回服务器接受此请求所用的端口号 
   14   BufferedReader getReader() 返回解码过了的请求体 
   15   String getRemoteAddr() 返回发送此请求的客户端IP地址 
   16   String getRemoteHost() 返回发送此请求的客户端主机名 
   17   void setAttribute(String key,Object obj) 设置属性的属性值 
   18   String getRealPath(String path) 返回一虚拟路径的真实路径 

2. response对象

     response对象包含了响应客户请求的有关信息，它是HttpServletResponse类的实例。

   1   String getCharacterEncoding() 返回响应用的是何种字符编码 
   2   ServletOutputStream getOutputStream() 返回响应的一个二进制输出流 
   3   PrintWriter getWriter() 返回可以向客户端输出字符的一个对象 
   4   void setContentLength(int len) 设置响应头长度 
   5   void setContentType(String type) 设置响应的MIME类型 
   6   sendRedirect(java.lang.String location) 重新定向客户端的请求 

3. session对象

   session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.

   1   long getCreationTime() 返回SESSION创建时间 
   2   public String getId() 返回SESSION创建时JSP引擎为它设的惟一ID号 
   3   long getLastAccessedTime() 返回此SESSION里客户端最近一次请求时间 
   4   int getMaxInactiveInterval() 返回两次请求间隔多长时间此SESSION被取消(ms) 
   5   String[] getValueNames() 返回一个包含此SESSION中所有可用属性的数组 
   6   void invalidate() 取消SESSION，使SESSION不可用 
   7   boolean isNew() 返回服务器创建的一个SESSION,客户端是否已经加入 
   8   void removeValue(String name) 删除SESSION中指定的属性 
   9   void setMaxInactiveInterval() 设置两次请求间隔多长时间此SESSION被取消(ms) 

4. out对象

    out对象是JspWriter类的实例,是向客户端输出内容常用的对象

   1   void clear() 清除缓冲区的内容 
   2   void clearBuffer() 清除缓冲区的当前内容 
   3   void flush() 清空流 
   4   int getBufferSize() 返回缓冲区以字节数的大小，如不设缓冲区则为0 
   5   int getRemaining() 返回缓冲区还剩余多少可用 
   6   boolean isAutoFlush() 返回缓冲区满时，是自动清空还是抛出异常 
   7   void close() 关闭输出流 

5. page对象

    page对象就是指向当前JSP页面本身，有点像类中的this指针，它是java.lang.Object类的实例

   1   class getClass 返回此Object的类 
   2   int hashCode() 返回此Object的hash码 
   3   boolean equals(Object obj) 判断此Object是否与指定的Object对象相等 
   4   void copy(Object obj) 把此Object拷贝到指定的Object对象中 
   5   Object clone() 克隆此Object对象 
   6   String toString() 把此Object对象转换成String类的对象 
   7   void notify() 唤醒一个等待的线程 
   8   void notifyAll() 唤醒所有等待的线程 
   9   void wait(int timeout) 使一个线程处于等待直到timeout结束或被唤醒 
   10   void wait() 使一个线程处于等待直到被唤醒 
   11   void enterMonitor() 对Object加锁 
   12   void exitMonitor() 对Object开锁 

6. application对象

   application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。

   1   Object getAttribute(String name) 返回给定名的属性值 
   2   Enumeration getAttributeNames() 返回所有可用属性名的枚举 
   3   void setAttribute(String name,Object obj) 设定属性的属性值 
   4   void removeAttribute(String name) 删除一属性及其属性值 
   5   String getServerInfo() 返回JSP(SERVLET)引擎名及版本号 
   6   String getRealPath(String path) 返回一虚拟路径的真实路径 
   7   ServletContext getContext(String uripath) 返回指定WebApplication的application对象 
   8   int getMajorVersion() 返回服务器支持的Servlet API的最大版本号 
   9   int getMinorVersion() 返回服务器支持的Servlet API的最小版本号 
   10   String getMimeType(String file) 返回指定文件的MIME类型 
   11   URL getResource(String path) 返回指定资源(文件及目录)的URL路径 
   12   InputStream getResourceAsStream(String path) 返回指定资源的输入流 
   13   RequestDispatcher getRequestDispatcher(String uripath) 返回指定资源的RequestDispatcher对象 
   14   Servlet getServlet(String name) 返回指定名的Servlet 
   15   Enumeration getServlets() 返回所有Servlet的枚举 
   16   Enumeration getServletNames() 返回所有Servlet名的枚举 
   17   void log(String msg) 把指定消息写入Servlet的日志文件 
   18   void log(Exception exception,String msg) 把指定异常的栈轨迹及错误消息写入Servlet的日志文件 
   19   void log(String msg,Throwable throwable) 把栈轨迹及给出的Throwable异常的说明信息 写入Servlet的日志文件 

7. exception对象

   exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象

   1   String getMessage() 返回描述异常的消息 
   2   String toString() 返回关于异常的简短描述消息 
   3   void printStackTrace() 显示异常及其栈轨迹 
   4   Throwable FillInStackTrace() 重写异常的执行栈轨迹 

8. pageContext对象

   pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本类名也叫pageContext。

   1   JspWriter getOut() 返回当前客户端响应被使用的JspWriter流(out) 
   2   HttpSession getSession() 返回当前页中的HttpSession对象(session) 
   3   Object getPage() 返回当前页的Object对象(page) 
   4   ServletRequest getRequest() 返回当前页的ServletRequest对象(request) 
   5   ServletResponse getResponse() 返回当前页的ServletResponse对象(response) 
   6   Exception getException() 返回当前页的Exception对象(exception) 
   7   ServletConfig getServletConfig() 返回当前页的ServletConfig对象(config) 
   8   ServletContext getServletContext() 返回当前页的ServletContext对象(application) 
   9   void setAttribute(String name,Object attribute) 设置属性及属性值 
   10   void setAttribute(String name,Object obj,int scope) 在指定范围内设置属性及属性值 
   11   public Object getAttribute(String name) 取属性的值 
   12   Object getAttribute(String name,int scope) 在指定范围内取属性的值 
   13   public Object findAttribute(String name) 寻找一属性,返回其属性值或NULL 
   14   void removeAttribute(String name) 删除某属性 
   15   void removeAttribute(String name,int scope) 在指定范围删除某属性 
   16   int getAttributeScope(String name) 返回某属性的作用范围 
   17   Enumeration getAttributeNamesInScope(int scope) 返回指定范围内可用的属性名枚举 
   18   void release() 释放pageContext所占用的资源 
   19   void forward(String relativeUrlPath) 使当前页面重导到另一页面 
   20   void include(String relativeUrlPath) 在当前位置包含另一文件 

9. config对象

    config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）

   1   ServletContext getServletContext() 返回含有服务器相关信息的ServletContext对象 
   2   String getInitParameter(String name) 返回初始化参数的值 
   3   Enumeration getInitParameterNames() 返回Servlet初始化所需所有参数的枚举 

#### Get和Post的区别

1. get是从服务器上获取数据，post是向服务器传送数据。 
2. get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。 
3. 对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据

> GET后退按钮/刷新无害，POST数据会被重新提交（浏览器应该告知用户数据会被重新提交）。
> GET书签可收藏，POST为书签不可收藏。
> GET能被缓存，POST不能缓存 。
> GET编码类型application/x-www-form-url，POST编码类型encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。
> GET历史参数保留在浏览器历史中。POST参数不会保存在浏览器历史中。
> GET对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。POST无限制。
> GET只允许 ASCII 字符。POST没有限制。也允许二进制数据。
> 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。
> GET的数据在 URL 中对所有人都是可见的。POST的数据不会显示在 URL 中

**重大区别** 

GET产生一个TCP数据包；POST产生两个TCP数据包。

对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

GET的语义是请求获取指定的资源。GET方法是安全、幂等、可缓存的（除非有 Cache-ControlHeader的约束）,GET方法的报文主体没有任何语义。

POST的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST不安全，不幂等，（大部分实现）不可缓存。

#### 转发和重定向的区别

**调用方式** 

- servlet

```
request.getRequestDispatcher("new.jsp").forward(request, response);   //转发到new.jsp
response.sendRedirect("new.jsp");   //重定向到new.jsp
```

- Jsp

```
<jsp:forward page="apage.jsp" />   //转发
<%response.sendRedirect("new.jsp"); %> //重定向到new.jsp
```

**本质**： 

转发是服务器行为，重定向是客户端行为

> 转发过程：客户浏览器发送http请求——》web服务器接受此请求——》调用内部的一个方法在容器内部完成请求处理和转发动作——》将目标资源发送给客户；在这里，转发的路径必须是同一个web容器下的url，其不能转向到其他的web路径上去，中间传递的是自己的容器内的request。在客户浏览器路径栏显示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。
>
> 请求转发是服务器内部把对一个request/response的处理权，移交给另外一个
>
> 对于客户端而言，它只知道自己最早请求的那个A，而不知道中间的B，甚至C、D。传输的信息不会丢失。

> 重定向过程：客户浏览器发送http请求——》web服务器接受后发送302状态码响应及对应新的location给客户浏览器——》客户浏览器发现是302响应，则**自动**再发送一个新的http请求，请求url是新的location地址——》服务器根据此请求寻找资源并发送给客户。在这里location可以重定向到任意URL，既然是浏览器重新发出了请求，则就没有什么request传递的概念了。在客户浏览器路径栏显示的是其重定向的路径，客户可以观察到地址的变化的。重定向行为是浏览器做了至少两次的访问请求的。
>
> 重定向，其实是两次request
>
> 第一次，客户端request   A,服务器响应，并response回来，告诉浏览器，你应该去B。这个时候IE可以看到地址变了，而且历史的回退按钮也亮了。重定向可以访问自己web应用以外的资源。在重定向的过程中，传输的信息会被丢失。

**区别**：

- 重定向时浏览器的网址改变，转发是浏览器上的网址不变
- 重定向实际上产生了两次请求，转发只有一次请求
- 重定向时的网址可以是任何网址，转发的网址必须是本站点的网址
- 重定向：以前的request中存放的变量全部失效，并进入一个新的request作用域。转发：以前的request中存放的变量不会失效，就像把两个页面拼到了一起。

## SQL

#### 如何让sql使用指定的索引

select * from tabel with(指定索引名)

或  select * from tabel with(INDEX =指定索引名)

#### 位图索引

**位图索引**是一种使用[位图](https://baike.so.com/doc/630856-667651.html)的特殊数据库索引。

主要针对大量相同值的列而创建(例如:类别，操作员，部门ID,库房ID等),索引块的一个索引行中存储键值和起止Rowid,以及这些键值的位置编码,

位置编码中的每一位表示键值对应的数据行的有无.一个块可能指向的是几十甚至成百上千行数据的位置.这种方式存储数据,相对于B*Tree索引,占用的空间非常小,创建和使用非常快.

当根据键值查询时,可以根据起始Rowid和位图状态,快速定位数据.

当根据键值做and,or或 in(x,y,..)查询时,直接用索引的位图进行或运算,快速得出结果行数据.

当select count(XX) 时,可以直接访问索引就快速得出统计数据.

```
创建语法
create bitmap index ssex_bitmap_index on zhou.student(ssex) 
tablespace MYSPACE; 
```

##### 位图索引的优势和不适合使用的场景

优势：

1. 位图索引使用于低基数的列，相对于B树索引，它的count,and,or操作更有效
2. 位图索引存放的是0,1的比特位，相对于B树索引，占字节数特别少?

不适用场景：

1. 列的基数比较多，不适合位图索引，因为它会占用更多的存储空间
2. 索引列DML频繁的列，不适合位图索引，容易造成死锁?

## Nginx

Nginx (engine x) 是一款轻量级的Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。

Nginx能做什么？

- 反向代理
- 负载均衡
- HTTP服务器（包含动静分离）
- 正向代理

Nginx可以支持热启动，Nginx从新读取配置的命令是：

` nginx -s reload`

> windows下是: 
>
> ​	nginx.exe -s reload

#### 反向代理

​        反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。

```
server {
        listen       80;                                                         
        server_name  localhost;                                               
        client_max_body_size 1024M;

        location / {
            proxy_pass http://localhost:8080;
            proxy_set_header Host $host:$server_port;
        }
    }
```

#### 正向代理

正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。当你需要把你的服务器作为代理服务器的时候，可以用Nginx来实现正向代理。

```
   resolver 114.114.114.114 8.8.8.8;
    server {

        resolver_timeout 5s;

        listen 81;

        access_log  e:\wwwroot\proxy.access.log;
        error_log   e:\wwwroot\proxy.error.log;

        location / {
            proxy_pass http://$host$request_uri;
        }
    }
```

 resolver是配置正向代理的DNS服务器，listen 是正向代理的端口，配置好了就可以在ie上面或者其他代理插件上面使用服务器ip+端口号进行代理了

##### 正向代理与反向代理比较

- 正向代理
  - 正向代理，我们的角色是 **被代理者**
  - 正向代理，我们不对外提供服务，反而是对外消费服务，属于消费者
- 反向代理
  - 反向代理，我们的角色是 **局域网 web服务**
  - 反向代理，我们对外提供服务，属于服务提供者

#### 负载均衡

负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡

常见的几种负载均衡策略：

1. **基于轮询   RR** （默认）

   每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。

简单配置：

```
    upstream test {
        server localhost:8080;
        server localhost:8081;
    }
    server {
        listen       81;                                                         
        server_name  localhost;                                               
        client_max_body_size 1024M;

        location / {
            proxy_pass http://test;
            proxy_set_header Host $host:$server_port;
        }
    }
```

核心代码：

```
 upstream test {
        server localhost:8080;
        server localhost:8081;
    }
```

`upstream`块定义一个后端小集群，里边配置相关的Server组成这个集群，同时`upstream`为这个集群起个相应的名字，本实例叫`test`.

`proxy_pass`处于`location`块中，表示对于所有符合`/`的request，将会交给哪个集群进行处理，本实例为`http://test`

如果协议使用`https`，则将`http`直接改成`https`即可。另外，如果你在`upstream`中的`server`指令中指定了协议名，那么在`proxy_pass`指令中就不需要加上协议名称了。

2. 权重

指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况

```
  upstream test {
        server localhost:8080 weight=9;
        server localhost:8081 weight=1;
    }
```

3. ip_hash

想让对于相同客户端的请求每次都被分发到同一个Server进行处理，上面两种策略都是不做到。此策略可确保来自同一客户端的请求始终定向到同一服务器，但此服务器不可用时除外。既然相同客户端的请求能被同一台Server进行处理，那么相同客户端的会话Session就可以实现持久化了。

```
    upstream test {
        ip_hash;
        server localhost:8080;
        server localhost:8081;
    }
```

4. 基于最少连接数

   该策略主要使用了`least_conn`指令，可以按照机器的实际情况进行刚需分配。

   ```
   upstream myapp1 {
      least_conn;
      server srv1.example.com;
      server srv2.example.com;
      server srv3.example.com;
   }
   ```

5. fair(第三方)

   按后端服务器的响应时间来分配请求，响应时间短的优先分配。

   ```
       upstream backend { 
           fair; 
           server localhost:8080;
           server localhost:8081;
       } 
   ```

6. url_hash（第三方）

   按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法

   ```
       upstream backend { 
           hash $request_uri; 
           hash_method crc32; 
           server localhost:8080;
           server localhost:8081;
       } 
   ```

**负载均衡健康检查**

当我们一个request进来被分发到相应的Server进行处理后，nginx会检查该request执行是否超时，是否执行失败了等情况，然后做出相应的处理；比如说当nginx检查出Server A执行某request时报出502错误了，那么下次nginx负载均衡时就会在`upstream`块中将Server A排除掉，不分发请求给到Server A了。

对于健康检查的功能，nginx提供了基本两个指令，即`max_fails`和`fail_timeout`,也就是说当nginx检查到某Server发生错误的request数达到`max_fails`或者执行某request执行时间超过`fail_timeout`了，如果发生超时了，nginx将开始使用实时请求优雅地探测Server，如果有响应，则认为对应的Server还是活着的，没有毛病的。

**负载均衡的作用**

- 转发功能：按照一定的算法【权重、轮询】，将客户端请求转发到不同应用服务器上，减轻单个服务器压力，提高系统并发量。
- 故障移除：通过心跳检测的方式，判断应用服务器当前是否可以正常工作，如果服务器期宕掉，自动将请求发送到其他应用服务器。
- 恢复添加：如检测到发生故障的应用服务器恢复工作，自动将其添加到处理用户请求队伍中。

#### HTTP服务器

Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现。

动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路

```
upstream test{  
       server localhost:8080;  
       server localhost:8081;  
    }   

    server {  
        listen       80;  
        server_name  localhost;  

        location / {  
            root   e:\wwwroot;  
            index  index.html;  
        }  

        # 所有静态请求都由nginx处理，存放目录为html  
        location ~ \.(gif|jpg|jpeg|png|bmp|swf|css|js)$ {  
            root    e:\wwwroot;  
        }  

        # 所有动态请求都转发给tomcat处理  
        location ~ \.(jsp|do)$ {  
            proxy_pass  http://test;  
        }  

        error_page   500 502 503 504  /50x.html;  
        location = /50x.html {  
            root   e:\wwwroot;  
        }  
    }  
```



## 网络编程

#### TCP/IP

TCP/IP是个协议组，可分为三个层次：网络层、传输层和应用层。 
在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。 
在传输层中有TCP协议与UDP协议。 
在应用层有:TCP包括FTP、HTTP、TELNET、SMTP等协议 
​                    UDP包括DNS、TFTP等协议 

**Socket**

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

#### TCP为何采用三次握手来建立连接

在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接

- 第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
- 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器 进入SYN_RECV状态；
- 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED状态，完成三次握手。

> **三次握手的最主要目的是保证连接是双工的，可靠更多的是通过重传机制来保证的。**

**为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。**

#### 为什么断开TCP连接需要进行四次握手 

立连接后，客户端和服务器都处于`ESTABLISED`状态。这时，客户端发起断开连接的请求：

- 客户端调用 close() 函数后，向服务器发送 FIN 数据包，进入`FIN_WAIT_1`状态。FIN 是 Finish 的缩写，表示完成任务需要断开连接。 

- 服务器收到数据包后，检测到设置了 FIN 标志位，知道要断开连接，于是向客户端发送“确认包”，进入`CLOSE_WAIT`状态。

  :arrow_forward:服务器收到请求后并不是立即断开连接，而是先向客户端发送“确认包”，告诉它我知道了，我需要准备一下才能断开连接

- 客户端收到“确认包”后进入`FIN_WAIT_2`状态，等待服务器准备完毕后再次发送数据包。

- 等待片刻后，服务器准备完毕，可以断开连接，于是再主动向客户端发送 FIN 包，告诉它我准备好了，断开连接吧。然后进入`LAST_ACK`状态。

- 客户端收到服务器的 FIN 包后，再向服务器发送 ACK 包，告诉它你断开连接吧。然后进入`TIME_WAIT`状态。

-  服务器收到客户端的 ACK 包后，就断开连接，关闭套接字，进入`CLOSED`状态。

因为TCP连接是全双工的网络协议，允许同时通信的双方同时进行数据的收发，同样也允许收发两个方向的连接被独立关闭，以避免client数据发送完毕，向server发送FIN关闭连接，而server还有发送到client的数据没有发送完毕的情况。所以关闭TCP连接需要进行四次握手，每次关闭一个方向上的连接需要FIN和ACK两次握手。

#### socket长连接和短连接区别

概念：长连接与短连接的概念：前者是整个通讯过程，客户端和服务端只用一个Socket对象，长期保持Socket的连接；后者是每次请求，都新建一个Socket,处理完一个请求就直接关闭掉Socket。所以，其实区分长短连接就是：整个客户和服务端的通讯过程是利用一个Socket还是多个Socket进行的。

**短连接**

连接->传输数据->关闭连接 
HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。 
也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。 

**长连接 **
连接->传输数据->保持连接 -> 传输数据-> 。。。 ->关闭连接。 
长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。 

> **http的长连接**
> HTTP也可以建立长连接的，使用Connection:keep-alive，HTTP 1.1默认进行持久连接。HTTP1.1和HTTP1.0相比较而言，最大的区别就是增加了持久连接支持(貌似最新的 http1.0 可以显示的指定 keep-alive),但还是无状态的，或者说是不可以信任的。 

#### socket异步与同步区别

**1、异步 **
报文发送和接收是分开的，相互独立的，互不影响。这种方式又分两种情况： 

- 异步双工：接收和发送在同一个程序中，由两个不同的子进程分别负责发送和接收 
- 异步单工：接收和发送是用两个不同的程序来完成。 

**2、同步 **
报文发送和接收是同步进行，即报文发送后等待接收返回报文。 同步方式一般需要考虑超时问题，即报文发出去后不能无限等待，需要设定超时时间，超过该时间发送方不再等待读返回报文，直接通知超时返回。

#### 单工、半双工和全双工

根据通信双方的分工和信号传输方向可将通信分为三种方式：单工、半双工与全双工。在计算机网络中主要采用双工方式，其中：局域网采用半双工方式，城域网和广域网采用全双工方式。

- 单工(Simplex)方式：通信双方设备中发送器与接收器分工明确，只能在由发送器向接收器的单一固定方向上传送数据。采用单工通信的典型发送设备如早期计算机的读卡器，典型的接收设备如打印机。
- 半双工(Half Duplex)方式：通信双方设备既是发送器，也是接收器，两台设备可以相互传送数据，但某一时刻则只能向一个方向传送数据。例如，步话机是半双工设备，因为在一个时刻只能有一方说话。
- 全双工(Full Duplex)方式：通信双方设备既是发送器，也是接收器，两台设备可以同时在两个方向上传送数据。例如，电话是全双工设备，因为双方可同时说话。

## HTTP与HTTPS

#### 简述http与https的区别

1. https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl(Secure Sockets Layer)加密传输协议。
3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

## 安全

#### 简述SHA1,MD5,AES,DES,RSA分别是什么？在什么场景下使用？

**加密技术通常分为两大类:"对称式"和"非对称式"。**

+ **对称性加密算法：**对称式加密就是加密和解密使用同一个密钥。信息接收双方都需事先知道密匙和加解密算法且其密匙是相同的，之后便是对数据进行加解密了。对称加密算法用来对敏感数据等信息进行加密。
+ **非对称算法：**非对称式加密就是加密和解密所使用的不是同一个密钥，通常有两个密钥，称为"公钥"和"私钥"，它们两个必需配对使用，否则不能打开加密文件。发送双方A,B事先均生成一堆密匙，然后A将自己的公有密匙发送给B，B将自己的公有密匙发送给A，如果A要给B发送消息，则先需要用B的公有密匙进行消息加密，然后发送给B端，此时B端再用自己的私有密匙进行消息解密，B向A发送消息时为同样的道理。
+ **散列算法：**散列算法，又称哈希函数，是一种单向加密算法。在信息安全技术中，经常需要验证消息的完整性，散列(Hash)函数提供了这一服务，它对不同长度的输入消息，产生固定长度的输出。这个固定长度的输出称为原输入消息的"散列"或"消息摘要"(Message digest)。散列算法不算加密算法，因为其结果是不可逆的，既然是不可逆的，那么当然不是用来加密的，而是签名。

**对称性加密算法有：AES、DES、3DES**

> 用途： 对称加密算法用来对敏感数据等信息进行加密

- **DES**（Data Encryption Standard）：数据加密标准，速度较快，适用于加密大量数据的场合。
- **3DES**（Triple DES）：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。
- **AES**（Advanced Encryption Standard）：高级加密标准，是下一代的加密算法标准，速度快，安全级别高；AES是一个使用128为分组块的分组加密算法，分组块和128、192或256位的密钥一起作为输入，对4×4的字节数组上进行操作。众所周之AES是种十分高效的算法，尤其在8位架构中，这源于它面向字节的设计。AES 适用于8位的小型单片机或者普通的32位微处理器,并且适合用专门的硬件实现，硬件实现能够使其吞吐量（每秒可以到达的加密/解密bit数）达到十亿量级。同样，其也适用于RFID系统。

**非对称性算法有：RSA、DSA、ECC**

- **RSA**：由 RSA 公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的。RSA在国外早已进入实用阶段，已研制出多种高速的RSA的专用芯片。
- **DSA**（Digital Signature Algorithm）：数字签名算法，是一种标准的 DSS（数字签名标准），严格来说不算加密算法。
- **ECC**（Elliptic Curves Cryptography）：椭圆曲线密码编码学。ECC和RSA相比，具有多方面的绝对优势，主要有：抗攻击性强。相同的密钥长度，其抗攻击性要强很多倍。计算量小，处理速度快。ECC总的速度比RSA、DSA要快得多。存储空间占用小。ECC的密钥尺寸和系统参数与RSA、DSA相比要小得多，意味着它所占的存贮空间要小得多。这对于加密算法在IC卡上的应用具有特别重要的意义。带宽要求低。当对长消息进行加解密时，三类密码系统有相同的带宽要求，但应用于短消息时ECC带宽要求却低得多。带宽要求低使ECC在无线网络领域具有广泛的应用前景。

**散列算法（签名算法）有：MD5、SHA1、HMAC**

> 用途：主要用于验证，防止信息被修改。具体用途如：文件校验、数字签名、鉴权协议

- **MD5**：MD5是一种不可逆的加密算法，目前是最牢靠的加密算法之一，尚没有能够逆运算的程序被开发出来，它对应任何字符串都可以加密成一段唯一的固定长度的代码。
- **SHA1**：是由NISTNSA设计为同DSA一起使用的，它对长度小于264的输入，产生长度为160bit的散列值，因此抗穷举(brute-force)性更好。SHA-1设计时基于和MD4相同原理,并且模仿了该算法。SHA-1是由美国标准技术局（NIST）颁布的国家标准，是一种应用最为广泛的Hash函数算法，也是目前最先进的加密技术，被政府部门和私营业主用来处理敏感的信息。而SHA-1基于MD5，MD5又基于MD4。
- **HMAC**：是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）,HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。也就是说HMAC是需要一个密钥的。所以，HMAC_SHA1也是需要一个密钥的，而SHA1不需要。

**Base64**：其实不是安全领域下的加密解密算法，只能算是一个编码算法，通常用于把二进制数据编码为可写的字符形式的数据，对数据内容进行编码来适合传输(可以对img图像编码用于传输)。这是一种可逆的编码方式。编码后的数据是一个字符串，其中包含的字符为：A-Z、a-z、0-9、+、/，共64个字符，其实是65个字符，“=”是填充字符。

**HTTPS**（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL(SSL使用40 位关键字作为RC4流加密算法)，因此加密的详细内容就需要SSL。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间），提供了身份验证与加密通讯方法；它的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

**区别**

> 1. AES：更快，兼容设备，安全级别高；
> 2. SHA1：公钥后处理回传
> 3. DES：本地数据，安全级别低
> 4. RSA：非对称加密，有公钥和私钥
> 5. MD5：防篡改

**主要应用** 

- 加密算法是可逆的，用来对敏感数据进行保护。散列算法(签名算法、哈希算法)是不可逆的，主要用于身份验证。
- 大量数据加密建议采用对称加密算法，提高加解密速度；小量的机密数据，可以采用非对称加密算法。

## Spring

#### Spring声明式事务

Spring声明式事务管理，通过Spring AOP实现声明式事务管理

事务的四种属性

1. **事务的传播方式**

> 事务传播行为：是指添加事物时的策略

- PROPAGATION_REQUIRED   如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。
- PROPAGATION_SUPPORTS    支持当前事务，如果当前没有事务，就以非事务方式执行。
- PROPAGATION_MANDATORY   使用当前的事务，如果当前没有事务，就抛出异常。
- PROPAGATION_REQUIRES_NEW   新建事务，如果当前存在事务，把当前事务挂起。
- PROPAGATION_NOT_SUPPORTED     以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
- PROPAGATION_NEVER     以非事务方式执行，如果当前存在事务，则抛出异常。
- PROPAGATION_NESTED   如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。

2. **事务隔离级别**

- ISOLATION_DEFAULT：用底层数据库的默认隔离级别
- ISOLATION_READ_UNCOMMITTED（未提交读）：最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）
- ISOLATION_READ_COMMITTED（提交读）：一个事务提交后才能被其他事务读取到（该隔离级别禁止其他事务读取到未提交事务的数据、所以还是会造成幻读、不可重复读）、sql server默认级别
- ISOLATION_REPEATABLE_READ（可重复读）：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（该隔离基本可防止脏读，不可重复读（重点在修改），但会出现幻读（重点在增加与删除））（MySql默认级别，更改可通过set transaction isolation level 级别）
- ISOLATION_SERIALIZABLE（序列化）：代价最高最可靠的隔离级别（该隔离级别能防止脏读、不可重复读、幻读）

>其他概念：
>
>- 丢失更新：两个事务同时更新一行数据，最后一个事务的更新会覆盖掉第一个事务的更新，从而导致第一个事务更新的数据丢失，这是由于没有加锁造成的；
>- 幻读：同样的事务操作过程中，不同时间段多次（不同事务）读取同一数据，读取到的内容不一致（一般是行数变多或变少）。
>- 脏读：一个事务读取到另外一个未提及事务的内容，即为脏读。
>- 不可重复读：同一事务中，多次读取内容不一致（一般行数不变，而内容变了）。

数据库隔离级别越高，执行代价越高，并发执行能力越差，因此在实际项目开发使用时要综合考虑，为了考虑并发性能一般使用提交读隔离级别，它能避免丢失更新和脏读。

3. 事务的超时值
4. 事务的只读标志


## 设计模式

> 工厂模式可以分为三类:
>
> - 简单工厂模式（Simple Factory） 
> - 工厂方法模式（Factory Method） 
> - 抽象工厂模式（Abstract Factory） 
>
> > 这三种模式从上到下逐步抽象，并且更具一般性 
> >
> > 工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。
> >
> > 将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。 

### 工厂方法模式

> 定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。在工厂方法模式中，核心的工厂类不再负责所有的对象的创建，而是将具体创建的工作交给子类去做。这个核心类则摇身一变，成为了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个类应当被实例化这种细节。

- 一个抽象产品类，可以派生出多个具体产品类。   
- 一个抽象工厂类，可以派生出多个具体工厂类。   
- 每个具体工厂类只能创建一个具体产品类的实例。

工厂方法模式组成：

- 抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 
- 具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。 
- 抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 
- 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 

#### 简单工厂模式 

> 属于类的创新型模式，又叫静态工厂方法模式（Static FactoryMethod Pattern）,是通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

 简单工厂模式中包含的角色及其相应的职责:

- 工厂角色（Creator）：这是简单工厂模式的核心，由它负责创建所有的类的内部逻辑。当然工厂类必须能够被外界调用，创建所需要的产品对象。
- 抽象（Product）产品角色：简单工厂模式所创建的所有对象的父类，注意，这里的父类可以是接口也可以是抽象类，它负责描述所有实例所共有的公共接口。
- 具体产品（Concrete Product）角色：简单工厂所创建的具体实例对象，这些具体的产品往往都拥有共同的父类。

**核心思想：有一个专门的类来负责创建实例的过程。**

优点：工厂类是整个模式的关键所在。它包含必要的判断逻辑，能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。用户在使用时可以直接根据工厂类去创建所需的实例，而无需了解这些对象是如何创建以及如何组织的。有利于整个软件体系结构的优化。

缺点：由于工厂类集中了所有实例的创建逻辑，这就直接导致一旦这个工厂出了问题，所有的客户端都会受到牵连；而且由于简单工厂模式的产品室基于一个共同的抽象类或者接口，这样一来，当产品的种类增加的时候，即有不同的产品接口或者抽象类的时候，工厂类就需要判断何时创建何种种类的产品，这就和创建何种种类产品的产品相互混淆在了一起，违背了单一职责，导致系统丧失灵活性和可维护性。而且更重要的是，简单工厂模式违背了“开放封闭原则”，就是违背了“系统对扩展开放，对修改关闭”的原则，因为当我新增加一个产品的时候必须修改工厂类，相应的工厂类就需要重新编译一遍。

### 抽象工厂模式

> 为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。在以下情况下，适用于工厂方法模式:
>
> - (1) 当一个类不知道它所必须创建的对象的类的时候。
> - (2) 当一个类希望由它的子类来指定它所创建的对象的时候。
> - (3) 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。

- 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。   
- 一个抽象工厂类，可以派生出多个具体工厂类。   
- 每个具体工厂类可以创建多个具体产品类的实例。 

### 代理模式

> 为其他对象提供一种代理以控制对这个对象的访问。所谓代理，就是一个人或者机构代表另一个人或者机构采取行动。在一些情况下，一个客户不想或者不能够直接引用一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。
>
> 提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能.

**代理模式的关键点是:代理对象与目标对象.代理对象是对目标对象的扩展,并会调用目标对象.**

#### 静态代理

> 静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类.

**优点**：可以做到在符合开闭原则的情况下对目标对象进行功能扩展。

**缺点**：我们得为每一个服务都得创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得相应修改。

#### 动态代理

>  特点：
>
>  - 代理对象,不需要实现接口
>  - 代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)
>  - 动态代理也叫做:JDK代理,接口代理

**JDK中生成代理对象的API**      代理类所在包 :    ` java.lang.reflect.Proxy`

JDK实现代理只需要使用newProxyInstance方法,

```
static Object newProxyInstance(ClassLoader loader, 
            Class[] interfaces,InvocationHandler h )
```

该方法是在Proxy类中是静态方法,且接收的三个参数依次为:

- ClassLoader loader,:指定当前目标对象使用类加载器,获取加载器的方法是固定的
- Class[] interfaces,:目标对象实现的接口的类型,使用泛型方式确认类型
- InvocationHandler h:事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入

**注意**    代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理

```
/**
* 创建动态代理对象
* 动态代理不需要实现接口,但是需要指定接口类型
*/
public class ProxyFactory{

   //维护一个目标对象
   private Object target;
   public ProxyFactory(Object target){
       this.target=target;
   }

  //给目标对象生成代理对象
   public Object getProxyInstance(){
       return Proxy.newProxyInstance(
               target.getClass().getClassLoader(),
               target.getClass().getInterfaces(),
               new InvocationHandler() {
                   @Override
                   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                       System.out.println("开始事务2");
                       //执行目标对象方法
                       Object returnValue = method.invoke(target, args);
                       System.out.println("提交事务2");
                       return returnValue;
                   }
               }
       );
   }

}
```

```
// 目标对象
IUserDao target = new UserDao();
// 给目标对象，创建代理对象
IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance();
```



#### CGLIB代理

> 以目标对象子类的方式类实现代理
>
> Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.
>
> JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现.
>
> Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉.

**Cglib子类代理实现方法:**

1. 需要引入cglib的jar文件,但是Spring的核心包中已经包括了Cglib功能,所以直接引入spring-core-3.2.5.jar即可.
2. 引入功能包后,就可以在内存中动态构建子类
3. 代理的类不能为final,否则报错
4. 目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法.


> CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理。JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。

```
/**
* Cglib子类代理工厂
* 对UserDao在内存中动态构建一个子类对象
*/
public class ProxyFactory implements MethodInterceptor{
   //维护目标对象
   private Object target;

   public ProxyFactory(Object target) {
       this.target = target;
   }

   //给目标对象创建一个代理对象
   public Object getProxyInstance(){
       //1.工具类
       Enhancer en = new Enhancer();
       //2.设置父类
       en.setSuperclass(target.getClass());
       //3.设置回调函数
       en.setCallback(this);
       //4.创建子类(代理对象)
       return en.create();

   }

   @Override
   public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
       System.out.println("开始事务...");

       //执行目标对象的方法
       Object returnValue = method.invoke(target, args);

       System.out.println("提交事务...");

       return returnValue;
   }
}
```

```
       //目标对象
       UserDao target = new UserDao();
       //代理对象
       UserDao proxy = (UserDao)new ProxyFactory(target).getProxyInstance();
```

> **总结**： 
>
>  **在Spring的AOP编程中:**
>
> 如果加入容器的目标对象有实现接口,用JDK代理.
> 如果目标对象没有实现接口,用Cglib代理.
>
> CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。同时由于CGLib由于是采用动态创建子类的方法，对于final修饰的方法无法进行代理。

### 单例模式

确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。单例模式注意事项：

只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。不要做断开单例类对象与类中静态引用的危险操作。多线程使用单例使用共享资源时，注意线程安全问题。

**实现要点**

- 声明为private来隐藏构造器
- private static Singleton实例
- 声明为public来暴露实例获取方法

单例模式主要追求三个方面性能

- 线程安全
- 调用效率高
- 延迟加载

> 单例模式有很多好处，它能够避免实例对象的重复创建，不仅可以减少每次创建对象的时间开销，还可以节约内存空间；能够避免由于操作多个实例导致的逻辑错误。如果一个对象有可能贯穿整个应用程序，而且起到了全局统一管理控制的作用，那么单例模式也许是一个值得考虑的选择。

#### 饿汉模式

```

public class Singleton{
    private static Singleton instance = new Singleton();
    private Singleton(){}
    public static Singleton newInstance(){
        return instance;
    }
}
```

> 好处是只在类加载的时候创建一次实例，不会存在多个线程创建多个实例的情况，避免了多线程同步的问题。它的缺点也很明显，即使这个单例没有用到也会被创建，而且在类加载之后就被创建，内存就被浪费了。
>
> 这种实现方式适合单例占用内存比较小，在初始化时就会被用到的情况。

#### 懒汉模式

```
public class Singleton{
    private static Singleton instance = null;
    private Singleton(){}
    public static Singleton newInstance(){
        if(null == instance){
            instance = new Singleton();
        }
        return instance;
    }
}
```

> 懒汉模式中单例是在需要的时候才去创建的，如果单例已经创建，再次调用获取接口将不会重新创建新的对象，而是直接返回之前创建的对象。
>
> 这里的懒汉模式并没有考虑线程安全问题，在多个线程可能会并发调用它的getInstance()方法，导致创建多个实例，因此需要加锁解决线程同步问题

**加锁版本**

```
public class Singleton{
    private static Singleton instance = null;
    private Singleton(){}
    public static synchronized Singleton newInstance(){
        if(null == instance){
            instance = new Singleton();
        }
        return instance;
    }
}
```

#### 双重校验锁

> 加锁的懒汉模式看起来即解决了线程并发问题，又实现了延迟加载，然而它存在着性能问题，依然不够完美。synchronized修饰的同步方法比一般方法要慢很多，如果多次调用getInstance()，累积的性能损耗就比较大了。因此就有了双重校验锁

```
public class Singleton {
    private static volatile Singleton instance = null;
    private Singleton(){}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

volatile的一个语义是禁止指令重排序优化，也就保证了instance变量被赋值的时候对象已经是初始化过的

#### 静态内部类

```
public class Singleton{
    private static class SingletonHolder{
        public static Singleton instance = new Singleton();
    }
    private Singleton(){}
    public static Singleton newInstance(){
        return SingletonHolder.instance;
    }
}
```

> 利用了类加载机制来保证只创建一个instance实例。它与饿汉模式一样，也是利用了类加载机制，因此不存在多线程并发的问题。不一样的是，它是在内部类里面去创建对象实例。这样的话，只要应用中不使用内部类，JVM就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载。也就是说这种方式可以同时保证延迟加载和线程安全。

#### 枚举

```
public enum Singleton{
    instance;
    public void whateverMethod(){}    
}
```

> 其他的四种实现单例的方式都有共同的缺点：
>
> - 需要额外的工作来实现序列化，否则每次反序列化一个序列化的对象时都会创建一个新的实例。
> - 可以使用反射强行调用私有构造器
>
> 而枚举类很好的解决了这两个问题，使用枚举除了线程安全和防止反射调用构造器之外，还提供了自动序列化机制，防止反序列化的时候创建新的对象。

- 线程安全

- 由于枚举类的会在编译期编译为继承自java.lang.Enum的类，其构造函数为私有，不能再创建枚举对象，枚举对象的声明和初始化都是在static块中，所以由JVM的ClassLoader机制保证了线程的安全性。但是不能实现延迟加载

- 序列化

  由于枚举类型采用了特殊的序列化方法，从而保证了在一个JVM中只能有一个实例

**单例模式性能总结**

| 方式     | 优点                | 缺点     |
| ------ | ----------------- | ------ |
| 饿汉式    | 线程安全，调用效率高        | 不能延迟加载 |
| 懒汉式    | 线程安全，可以延长加载       | 调用效率不高 |
| 双重校验锁式 | 线程安全，调用效率高，可以延长加载 |        |
| 静态内部类式 | 线程安全，调用效率高，可以延长加载 |        |
| 枚举单例   | 线程安全，调用效率高        | 不能延迟加载 |

**其他参考** ：[单例模式的破坏与防御](https://blog.csdn.net/jq_ak47/article/details/54894793)

## JVM

### JVM加载class文件的原理机制

### Java垃圾回收机制





 