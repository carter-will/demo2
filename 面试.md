## mybatis

### mybatis缓存机制

mybatis提供了缓存机制减轻数据库压力，提高数据库性能

查询缓存分为一级缓存和二级缓存

mybatis默认只开启一级缓存

一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效

二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的

#### 一级缓存

mybatis的一级缓存是SqlSession级别的缓存，在操作数据库的时候需要先创建SqlSession会话对象，在对象中有一个HashMap用于存储缓存数据，此HashMap是当前会话对象私有的，别的SqlSession会话对象无法访问。

**流程：** 

1. 第一次执行select完毕会将查到的数据写入SqlSession内的HashMap中缓存起来
2. 第二次执行select会从缓存中查数据，如果select相同切传参数一样，那么就能从缓存中返回数据，不用去数据库了，从而提高了效率

**注意：**  

1. 如果SqlSession执行了DML操作（insert、update、delete），并commit了，那么mybatis就会清空当前SqlSession缓存中的所有缓存数据，这样可以保证缓存中的存的数据永远和数据库中一致，避免出现脏读
2. 当一个SqlSession结束后那么他里面的一级缓存也就不存在了，mybatis默认是开启一级缓存，不需要配置
3. mybatis的缓存是基于[namespace:sql语句:参数]来进行缓存的，意思就是，SqlSession的HashMap存储缓存数据时，是使用[namespace:sql:参数]作为key，查询返回的语句作为value保存的。

#### 二级缓存

二级缓存是mapper级别的缓存，也就是同一个namespace的mappe.xml，当多个SqlSession使用同一个Mapper操作数据库的时候，得到的数据会缓存在同一个二级缓存区域

二级缓存默认是没有开启的。需要在setting全局参数中配置开启二级缓存  在conf.xml：

```
<settings>
        <setting name="cacheEnabled" value="true"/><!--默认是false：关闭二级缓存-->
<settings>
```

在xxxMapper.xml中配置：

```
<cache eviction="LRU" flushInterval="60000" size="512" readOnly="true"/><!--当前mapper下所有语句开启二级缓存-->
```

表示: 配置了一个LRU缓存，并每隔60秒刷新，最大存储512个对象，而却返回的对象是只读的

参数含义：

- flushInterval       刷新间隔，可以被设置为任意的正整数，代表一个合理的毫秒形式的时间段。默认情况是不设置，即没有刷新间隔，缓存仅仅调用语句时刷新
- size     引用数目缓存的对象数目和运行环境的可用内存资源数目，默认值1024
- readOnly    只读 ，只读的缓存会给所有调用者返回缓存对象的相同实例。
- evivtion    回收策略，默认为LRU.常用的策略有：
  - LRU   - 最近最少使用的： 移除最长时间不被使用的对象
  - FIFO   - 先进先出：按对象进入缓存的顺序来移除它们
  - SOFT  - 软引用：移除基于垃圾回收器状态和软引用规则的对象
  - WEAK  - 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象

**流程：**

1. 当一个sqlseesion执行了一次select后，在关闭此session的时候，会将查询结果缓存到二级缓存
2. 当另一个sqlsession执行select时，首先会在他自己的一级缓存中找，如果没找到，就回去二级缓存中找，找到了就返回，就不用去数据库了，从而减少了数据库压力提高了性能　

**注意：**

1. 如果SqlSession执行了DML操作（insert、update、delete），并commit了，那么mybatis就会清空当前mapper缓存中的所有缓存数据，这样可以保证缓存中的存的数据永远和数据库中一致，避免出现脏读
2. mybatis的缓存是基于[namespace:sql语句:参数]来进行缓存的，意思就是，SqlSession的HashMap存储缓存数据时，是使用[namespace:sql:参数]作为key，查询返回的语句作为value保存的。

> 使用二级缓存时，与查询结果映射的java对象必须实现java.io.Serializable接口的序列化和反序列化操作，如果存在父类，其成员都需要实现序列化接口，实现序列化接口是为了对缓存数据进行序列化和反序列化操作，因为二级缓存数据存储介质多种多样，不一定在内存，有可能是硬盘或者远程服务器。

## Redis

### redis的使用场景

redis最常用的物种数据格式：   1.String   2.Hash   3.List   4.Set   5.Sorted set  

1. String 

   | 常用命令          | 应用场景                                   |
   | ------------- | -------------------------------------- |
   | set、get       | 最简单的数据缓存                               |
   | mset、mget     | 批量操作，把数据统一传回客户端，节省网络io时间               |
   | decr、incr     | 计数器                                    |
   | append        | 可以作为时间序列，配合getrange、setrange,对字符串进行操作， |
   | setbit、getbit | 可以作为简单的布尔过滤器来判断用户是否执行过某些操作             |

2. List

   | 常用命令        | 应用场景        |
   | ----------- | ----------- |
   | lpush、lpop  | 队列操作，实现队列任务 |
   | lpush、ltrim | 显示最新的数据     |

3. Hash

   | 常用命令                | 应用场景                                     |
   | ------------------- | ---------------------------------------- |
   | hget、hset           | 实现一个key对应一个数据集集合，数据集集合里包含多个单独的key/value，操作依然是原子性的 |
   | hmget、hmset、hgetall | 批量操作，节省网络io时间                            |
   | hincrby             | 对哈希里域值，进行原子性加1                           |

4. Set

   | 常用命令                | 应用场景            |
   | ------------------- | --------------- |
   | sadd                | 存储一个不重复的数据      |
   | sunion、sdiff、sinter | 进行集合处理，并集、交集、差集 |

5. Sorted Set

   | 常用命令                 | 应用场景                      |
   | -------------------- | ------------------------- |
   | zadd                 | 存储一个按照score排序的数据集合，添加自动排序 |
   | zrange、zrangebyscore | 按照score顺序获取数据集            |
   | zrank                | 排行榜功能                     |

常见使用场景：

- 会话缓存（Session cache） redis提供持久化。

- 热数据缓存

- 全页缓存(FPC)   极大的提高网页的响应速率

- 队列   相当于消息系统，ActiveMQ，RocketMQ等工具类似；队列不仅可以把并发请求变成串行，并且还可以做队列或者栈使用

- 排行榜/计数器   Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单；诸如统计点击数等应用。由于单线程，可以避免并发问题，保证不会出错，而且100%毫秒级性能！

- 发布/订阅功能

- 位操作   用于数据量上亿的场景下。

  redis内构建一个足够长的数组，每个数组元素只能是0和1两个值，然后这个数组的下标index用来表示我们上面例子里面的用户id（必须是数字哈），那么很显然，这个几亿长的大数组就能通过下标和元素值（0和1）来构建一个记忆系统

- 分布式锁与单线程机制

  - 验证前端的重复请求，可以通过redis进行过滤：每次请求将request ip、参数、接口等hash作为key存储redis(幂等性请求)。设置多长时间有效期，然后下次请求过来的时候先在redis中检索有没有这个key，进而验证是不是一定时间内过来的重复请求
  - 秒杀系统，基于redis是单线程特征，防止出现数据库爆破
  - 全局增量ID 生成





