[TOC]

## mybatis

### mybatis缓存机制

mybatis提供了缓存机制减轻数据库压力，提高数据库性能

查询缓存分为一级缓存和二级缓存

mybatis默认只开启一级缓存

一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效

二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的

#### 一级缓存

mybatis的一级缓存是SqlSession级别的缓存，在操作数据库的时候需要先创建SqlSession会话对象，在对象中有一个HashMap用于存储缓存数据，此HashMap是当前会话对象私有的，别的SqlSession会话对象无法访问。

**流程：** 

1. 第一次执行select完毕会将查到的数据写入SqlSession内的HashMap中缓存起来
2. 第二次执行select会从缓存中查数据，如果select相同切传参数一样，那么就能从缓存中返回数据，不用去数据库了，从而提高了效率

**注意：**  

1. 如果SqlSession执行了DML操作（insert、update、delete），并commit了，那么mybatis就会清空当前SqlSession缓存中的所有缓存数据，这样可以保证缓存中的存的数据永远和数据库中一致，避免出现脏读
2. 当一个SqlSession结束后那么他里面的一级缓存也就不存在了，mybatis默认是开启一级缓存，不需要配置
3. mybatis的缓存是基于[namespace:sql语句:参数]来进行缓存的，意思就是，SqlSession的HashMap存储缓存数据时，是使用[namespace:sql:参数]作为key，查询返回的语句作为value保存的。

#### 二级缓存

二级缓存是mapper级别的缓存，也就是同一个namespace的mappe.xml，当多个SqlSession使用同一个Mapper操作数据库的时候，得到的数据会缓存在同一个二级缓存区域

二级缓存默认是没有开启的。需要在setting全局参数中配置开启二级缓存  在conf.xml：

```
<settings>
        <setting name="cacheEnabled" value="true"/><!--默认是false：关闭二级缓存-->
<settings>
```

在xxxMapper.xml中配置：

```
<cache eviction="LRU" flushInterval="60000" size="512" readOnly="true"/><!--当前mapper下所有语句开启二级缓存-->
```

表示: 配置了一个LRU缓存，并每隔60秒刷新，最大存储512个对象，而却返回的对象是只读的

参数含义：

- flushInterval       刷新间隔，可以被设置为任意的正整数，代表一个合理的毫秒形式的时间段。默认情况是不设置，即没有刷新间隔，缓存仅仅调用语句时刷新
- size     引用数目缓存的对象数目和运行环境的可用内存资源数目，默认值1024
- readOnly    只读 ，只读的缓存会给所有调用者返回缓存对象的相同实例。
- evivtion    回收策略，默认为LRU.常用的策略有：
  - LRU   - 最近最少使用的： 移除最长时间不被使用的对象
  - FIFO   - 先进先出：按对象进入缓存的顺序来移除它们
  - SOFT  - 软引用：移除基于垃圾回收器状态和软引用规则的对象
  - WEAK  - 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象

**流程：**

1. 当一个sqlseesion执行了一次select后，在关闭此session的时候，会将查询结果缓存到二级缓存
2. 当另一个sqlsession执行select时，首先会在他自己的一级缓存中找，如果没找到，就回去二级缓存中找，找到了就返回，就不用去数据库了，从而减少了数据库压力提高了性能　

**注意：**

1. 如果SqlSession执行了DML操作（insert、update、delete），并commit了，那么mybatis就会清空当前mapper缓存中的所有缓存数据，这样可以保证缓存中的存的数据永远和数据库中一致，避免出现脏读
2. mybatis的缓存是基于[namespace:sql语句:参数]来进行缓存的，意思就是，SqlSession的HashMap存储缓存数据时，是使用[namespace:sql:参数]作为key，查询返回的语句作为value保存的。

> 使用二级缓存时，与查询结果映射的java对象必须实现java.io.Serializable接口的序列化和反序列化操作，如果存在父类，其成员都需要实现序列化接口，实现序列化接口是为了对缓存数据进行序列化和反序列化操作，因为二级缓存数据存储介质多种多样，不一定在内存，有可能是硬盘或者远程服务器。

#### hiberante的缓存

Hibernate中提供了两级缓存，一级缓存是Session级别的缓存，它属于事务范围的缓存，该级缓存由hibernate管理，应用程序无需干预；二级缓存是SessionFactory级别的缓存，该级缓存可以进行配置和更改，并且可以动态加载和卸载，hibernate还为查询结果提供了一个查询缓存，它依赖于二级缓存

#### 缓存概念

缓存是位于应用程序和永久性数据存储源之间用于临时存放复制数据的内存区域，缓存可以降低应用程序之间读写永久性数据存储源的次数，从而提高应用程序的运行性能。

参考[计算机缓存结构](https://blog.csdn.net/hujutaoseu/article/details/56842762)

缓存范围决定了缓存的生命周期，缓存范围分为3类：

1. 事务范围：

   缓存只能被当前事务访问，缓存的生命周期依赖于事务的生命周期，事务结束时，缓存的生命周期也结束了；

2. 进程范围：

   缓存被进程内的所有事务共享，这些事务会并发访问缓存，需要对缓存采用必要的事务隔离机制，缓存的生命周期取决与进程的生命周期，进程结束，缓存的生命周期也结束了；

3. 集群范围：

   缓存被一个或多个计算机的进程共享，缓存中的数据被复制到集群中的每个进行节点，进程间通过远程通信来保证缓存中数据的一致性；

   在查询时，如果在事务范围内的缓存中没有找到，可以到进程范围或集群范围的缓存中查找，如果还没找到，则到数据库中查询；

## 缓存

### 缓存穿透、缓存并发、缓存失效、缓存雪崩

**缓存穿透**

缓存穿透指的是使用不存在的key进行大量的高并发查询，这导致缓存无法命中，每次请求都要穿透到后端数据库系统进行查询，使数据库压力过大，甚至使数据库服务被压死。

​:arrow_forward: 我们通常将空值缓存起来，再次接收到同样的查询请求时，若命中缓存并且值为空，就会直接返回，不会透传到数据库，避免缓存穿透。

(如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。)

:arrow_forward:采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

**缓存并发**

缓存并发的问题通常发生在高并发的场景下，当一个缓存key过期时，因为访问这个缓存key 的请求量较大，多个请求同时发现缓存过期，因此多个请求会同时访问数据库来查询最新数据，并且回写缓存，这样会造成应用和数据库的负载增加，性能降低，由于并发较高，甚至会导致数据库被压死。

​:arrow_forward: **分布式锁** 使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。这种情况和刚才说的预先设定值问题有些类似，只不过利用锁的方式，会造成部分请求等待。

:arrow_forward:**本地锁** 与分布式锁类似，我们通过本地锁的方式来限制只有一个线程去数据库中查询数据，而其他线程只需等待，等前面的线程查询到数据后再访问缓存。但是，这种方法只能限制一个服务节点只有一个线程去数据库中查询，如果一个服务有多个节点，则还会有多个数据库查询操作，也就是说在节点数量较多的情况下并没有完全解决缓存并发的问题。

:arrow_forward:**软过期** 软过期指对缓存中的数据设置失效时间，就是不使用缓存服务提供的过期时间，而是业务层在数据中存储过期时间信息，由业务程序判断是否过期并更新，在发现了数据即将过期时，将缓存的时效延长，程序可以派遣一个线程去数据库中获取最新的数据，其他线程这时看到延长了的过期时间，就会继续使用旧数据，等派遣的线程获取最新数据后再更新缓存。

*也可以通过异步更新服务来更新设置软过期的缓存，这样应用层就不用关心缓存并发的问题了。*

**缓存失效**

引起这个问题的主要原因还是高并发的时候，平时我们设定一个缓存的过期时间时，可能有一些会设置1分钟啊，5分钟这些，并发很高时可能会出在某一个时间同时生成了很多的缓存，并且过期时间都一样，这个时候就可能引发一当过期时间到后，这些缓存同时失效，请求全部转发到DB，DB可能会压力过重。

​:arrow_forward: 将缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。 

:arrow_forward:分析用户行为，尽量让失效时间点均匀分布

**缓存雪崩**

缓存雪崩指缓存服务器重启或者大量缓存集中在某一个时间段内失效，给后端数据库造成瞬时的负载升高的压力，甚至压垮数据库的情况。

当发生大量的缓存穿透，例如对某个失效的缓存的大并发访问就造成了缓存雪崩。

​:arrow_forward: 对不同的数据使用不同的失效时间，甚至对相同的数据、不同的请求使用不同的失效时间.

:arrow_forward:考虑用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，避免缓存失效时对数据库造成太大的压力，虽然能够在一定的程度上缓解了数据库的压力但是与此同时又降低了系统的吞吐量。

:arrow_forward:如果是因为某台缓存服务器宕机，可以考虑做主备

**缓存预热**

存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！

实现思路：

1. 直接写个缓存刷新页面，上线时手工操作下；
2. 数据量不大，可以在项目启动的时候自动进行加载；
3. 定时刷新缓存。

**缓存更新**

 除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：

- 定时去清理过期的缓存；
- 当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。

> 第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！

**缓存降级**

 当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。

降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的。

​:bang:  在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：

- 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；
- 警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；
- 错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；
- 严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。

### 缓存算法

- FIFO算法：First in First out，先进先出。原则：一个数据最先进入缓存中，则应该最早淘汰掉。也就是说，当缓存满的时候，应当把最先进入缓存的数据给淘汰掉。
- LFU算法：Least Frequently Used，最不经常使用算法。
- LRU算法：Least Recently Used，近期最少使用算法。

> LRU和LFU的区别。LFU算法是根据在一段时间里数据项被使用的次数选择出最少使用的数据项，即根据使用次数的差异来决定。而LRU是根据使用时间的差异来决定的

### 缓存热点key问题

**问题**  我们通常使用 缓存 + 过期时间的策略来帮助我们加速接口的访问速度，减少了后端负载，同时保证功能的更新。但有两个问题如果同时出现，可能就会对系统造成致命的危害：

- 这个key是一个热点key
- 缓存的构建是需要一定时间的。

会有一个致命问题：在缓存失效的瞬间，有大量线程来构建缓存，造成后端负载加大，甚至可能会让系统崩溃 。

解决方案：

1. 使用互斥锁(mutex key)

   种解决方案思路比较简单，就是只让一个线程构建缓存，其他线程等待构建缓存的线程执行完，重新从缓存获取数据就可以了. 如果是单机，可以用synchronized或者lock来处理，如果是分布式环境可以用分布式锁就可以了（分布式锁，可以用memcache的add, redis的setnx, zookeeper的添加节点操作）。

   redis代码示例：

   ```
   public String get(key) {  
         String value = redis.get(key);  
         if (value == null) { //代表缓存值过期  
             //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db  
             if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {  //代表设置成功  
                  value = db.get(key);  
                         redis.set(key, value, expire_secs);  
                         redis.del(key_mutex);  
                 } else {  //这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可  
                         sleep(50);  
                         get(key);  //重试  
                 }  
             } else {  
                 return value;        
             }  
    }  
   ```

2.  "提前"使用互斥锁(mutex key)

   在value内部设置1个超时值(timeout1), timeout1比实际的memcache timeout(timeout2)小。当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache。然后再从数据库加载数据并设置到cache中。伪代码如下：

   ```
   v = memcache.get(key);    
   if (v == null) {    
       if (memcache.add(key_mutex, 3 * 60 * 1000) == true) {    
           value = db.get(key);    
           memcache.set(key, value);    
           memcache.delete(key_mutex);    
       } else {    
           sleep(50);    
           retry();    
       }    
   } else {    
       if (v.timeout <= now()) {    
           if (memcache.add(key_mutex, 3 * 60 * 1000) == true) {    
               // extend the timeout for other threads    
               v.timeout += 3 * 60 * 1000;    
               memcache.set(key, v, KEY_TIMEOUT * 2);    
               // load the latest value from db    
               v = db.get(key);    
               v.timeout = KEY_TIMEOUT;    
               memcache.set(key, value, KEY_TIMEOUT * 2);    
               memcache.delete(key_mutex);    
           } else {    
               sleep(50);    
               retry();    
           }    
       }    
   }
   ```

3. 永远不过期

   - 从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。
   - 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期

> 从实战看，这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。

```
String get(final String key) {    
        V v = redis.get(key);    
        String value = v.getValue();    
        long timeout = v.getTimeout();    
        if (v.timeout <= System.currentTimeMillis()) {    
            // 异步更新后台异常执行    
            threadPool.execute(new Runnable() {    
                public void run() {    
                    String keyMutex = "mutex:" + key;    
                    if (redis.setnx(keyMutex, "1")) {    
                        // 3 min timeout to avoid mutex holder crash    
                        redis.expire(keyMutex, 3 * 60);    
                        String dbValue = db.get(key);    
                        redis.set(key, dbValue);    
                        redis.delete(keyMutex);    
                    }    
                }    
            });    
        }    
        return value;    
}  
```

4. 资源保护

   采用netflix的hystrix，可以做资源的隔离保护主线程池，如果把这个应用到缓存的构建也未尝不可。

四中方式对比：

| 解决方案                | 优点                                       | 缺点                                       |
| ------------------- | ---------------------------------------- | ---------------------------------------- |
| 简单分布式互斥锁（mutex key） | 1.思路简单                        2.保证一直性    | 1.代码复杂度增大                                                                                                                                                     2.存在死锁的风险                                                                                                                                                                          3.  存在线程池阻塞 |
| “提前”使用互斥锁           | 保证一致性                                    | 同上                                       |
| 不过期                 | 异步构建缓存，不会阻塞线程池                           | 1.不保证一致性                                                                                                                                                           2.代码复杂度增大（每个value都要维护一个timekey）                                                                                                3.占用一定的内存空间（每个value都要维护一个timekey） |
| 资源隔离组件hystrix       | 1.hystrix技术成熟，有效保证后端                     2.hystrix监控强大 | 部分访问存在降级策略                               |

## Redis

### redis的使用场景

redis最常用的物种数据格式：   1.String   2.Hash   3.List   4.Set   5.Sorted set  

1. String 

   | 常用命令          | 应用场景                                   |
   | ------------- | -------------------------------------- |
   | set、get       | 最简单的数据缓存                               |
   | mset、mget     | 批量操作，把数据统一传回客户端，节省网络io时间               |
   | decr、incr     | 计数器                                    |
   | append        | 可以作为时间序列，配合getrange、setrange,对字符串进行操作， |
   | setbit、getbit | 可以作为简单的布尔过滤器来判断用户是否执行过某些操作             |

2. List

   | 常用命令        | 应用场景        |
   | ----------- | ----------- |
   | lpush、lpop  | 队列操作，实现队列任务 |
   | lpush、ltrim | 显示最新的数据     |

3. Hash

   | 常用命令                | 应用场景                                     |
   | ------------------- | ---------------------------------------- |
   | hget、hset           | 实现一个key对应一个数据集集合，数据集集合里包含多个单独的key/value，操作依然是原子性的 |
   | hmget、hmset、hgetall | 批量操作，节省网络io时间                            |
   | hincrby             | 对哈希里域值，进行原子性加1                           |

4. Set

   | 常用命令                | 应用场景            |
   | ------------------- | --------------- |
   | sadd                | 存储一个不重复的数据      |
   | sunion、sdiff、sinter | 进行集合处理，并集、交集、差集 |

5. Sorted Set

   | 常用命令                 | 应用场景                      |
   | -------------------- | ------------------------- |
   | zadd                 | 存储一个按照score排序的数据集合，添加自动排序 |
   | zrange、zrangebyscore | 按照score顺序获取数据集            |
   | zrank                | 排行榜功能                     |

常见使用场景：

- 会话缓存（Session cache） redis提供持久化。

- 热数据缓存

- 全页缓存(FPC)   极大的提高网页的响应速率

- 队列   相当于消息系统，ActiveMQ，RocketMQ等工具类似；队列不仅可以把并发请求变成串行，并且还可以做队列或者栈使用

- 排行榜/计数器   Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单；诸如统计点击数等应用。由于单线程，可以避免并发问题，保证不会出错，而且100%毫秒级性能！

- 发布/订阅功能

- 位操作   用于数据量上亿的场景下。

  redis内构建一个足够长的数组，每个数组元素只能是0和1两个值，然后这个数组的下标index用来表示我们上面例子里面的用户id（必须是数字哈），那么很显然，这个几亿长的大数组就能通过下标和元素值（0和1）来构建一个记忆系统

- 分布式锁与单线程机制

  - 验证前端的重复请求，可以通过redis进行过滤：每次请求将request ip、参数、接口等hash作为key存储redis(幂等性请求)。设置多长时间有效期，然后下次请求过来的时候先在redis中检索有没有这个key，进而验证是不是一定时间内过来的重复请求
  - 秒杀系统，基于redis是单线程特征，防止出现数据库爆破
  - 全局增量ID 生成


## Error与Exception

Error类和Exception类的父类都是throwable类。

- Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。
- Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。

#### CheckedException与RuntimeEception的区别

- 运行时异常（Runtime Exception）

  > 运行时异常;ArithmaticException,IllegalArgumentException，编译能通过，但是一运行就终止了，程序不会处理运行时异常，出现这类异常，程序会终止。

- 受检查的异常(Checked Exception )

  > 受检查的异常，要么用try。。。catch捕获，要么用throws字句声明抛出，交给它的父类处理，否则编译不会通过。

## 反射

#### Class.forName和ClassLoader区别

java中class.forName()和classLoader都可用来对类进行加载。

- class.forName()前者除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。
- classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。

Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象。如果程序依赖于Class是否被初始化，就必须用Class.forName(name)了。

## JVM相关

#### 什么情况下会发生栈内存溢出？

一般情况下有两种栈溢出情况：

- 如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量的时候，java虚拟机将抛出一个StackOverFlowError异常。
- 如果java虚拟机栈可以动态拓展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成拓展，或者在建立新线程的时候没有足够的内存去创建对应的虚拟机栈，那java虚拟机将会抛出一个OutOfMemoryError异常。

## 泛型

#### 泛型概念

泛型（Generic type 或者 generics）是对 Java 语言的类型系统的一种扩展，以支持创建可以按类型进行参数化的类。可以把类型参数看作是使用参数化类型时指定的类型的一个占位符，就像方法的形式参数是运行时传递的值的占位符一样。

*泛型还有一种较为准确的说法就是为了参数化类型，或者说可以将类型当作参数传递给一个类或者是方法。*

*泛型就是对参数类型的增强。允许一些自定义类型作为泛型的参数类型*

好处：

1. 类型安全。 泛型的主要目标是提高 Java 程序的类型安全。
2. 消除强制类型转换。
3. 潜在的性能收益。

泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做**类型擦除。**

> 泛型类或者泛型方法中，不接受 8 种基本数据类型

## Java基础

#### 如何从一个static方法对非static方法进行调用

​:a:  不可以在一个static方法内部发出对非static方法的调用；static方法是静态方法，是属于类的方法，非static方法是属于对象的方法。

所以在static方法中想要调用非static方法，要先新创建一个对象，再有这个对象来调用非static方法。

#### java中如何跳出当前的多重嵌套循环

​:a: 要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的的break语句，即可跳出

```
ok:
for(int i = 0;i<10;i++){
  for(int j = 0;j<10;j++){
    if(j == 5) break ok;
  }
}
```

#### java中如何实现动态数组

​:a: 当想增加数组大小时，就另开一个新的数组，把旧的数组放入其中即可

System.arraycopy(src, 0, dest, 0, src.length);    //关键方法

## JavaWeb

#### web.xml配置文件

参考: 1.   [web.xml配置](https://www.jianshu.com/p/bdf19d50a723)

2.   [web.xml元素](http://www.cnblogs.com/hafiz/p/5715523.html)

#### tomcat处理一个Http请求过程

*假设请求地址   http://localhost:8080/wsota/wsota_index.jsp*

1. 请求被发送到本机端口8080，被在那里侦听的Coyote HTTP/1.1 Connector获得
2. Connector把该请求交给它所在的Service的Engine来处理，并等待来自Engine的回应
3. Engine获得请求localhost/wsota/wsota_index.jsp，匹配它所拥有的所有虚拟主机Host
4. Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机）
5. localhost Host获得请求/wsota/wsota_index.jsp，匹配它所拥有的所有Context
6. Host匹配到路径为/wsota的Context（如果匹配不到就把该请求交给路径名为”"的Context去处理）
7. path=”/wsota”的Context获得请求/wsota_index.jsp，在它的mapping table中寻找对应的servlet
8. Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类
9. 构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法
10. Context把执行完了之后的HttpServletResponse对象返回给Host
11. Host把HttpServletResponse对象返回给Engine
12. Engine把HttpServletResponse对象返回给Connector
13. Connector把HttpServletResponse对象返回给客户browser

#### Tomcat启动过程

通过bin目录下的startup.bat来启动tomcat，startup.bat又调用了catalina.bat，catalina.bat从命令行启动org.apache.catalina.startup.Bootstrap，这个类有main方法，所以可以从命令行执行。

Bootstrap执行后，首先执行init()方法进行初始化，然后调用load()和start()方法。下面具体介绍init()方法、load()、start()方法

1. init()

   首先设置catalina.home，catalina.base这两个环境变量；

   创建了三个类加载器

   根据conf/catalina.properties中的配置，初始化了三个ClassLoader：commonLoader、catalinaLoader、sharedLoader；并且把catalinaLoader设置为当前线程上下文的类加载器；然后创建Catalina类的对象（变量名是catalinaDaemon）：

   ```
   Class startupClass =catalinaLoader.loadClass ("org.apache.catalina.startup.Catalina");
   Object startupInstance = startupClass.newInstance();
   ```

2. load()

   通过反射机制，调用catalina对象的load()方法------在该方法中，初始化一些目录，比如temp目录，初始化名称空间，如java:env；然后使用Digester的方式，根据server.xml的配置来装配tomcat的各个组件，这里暂时提一下tomcat的结构，tomcat顶层组件是Server，Server下面有多个Service组件，还有Connector、Engin、Host等。装配组件的过程中，生成了各个组件的对象，并设置了他们之间的关联关系。

3. start()

   该方法里面，通过反射机制，调用了Catalina对象的start()方法。Catalina对象的start()方法又调用了Server对象的Start()方法，并设置关闭Server的回调方法。

#### JVM类加载过程

当jvm运行时，需要加载某些类：（父类委托机制）

1.  用户自己的类加载器，把加载请求传给父加载器，父加载器再传给其父加载器，一直到加载器树的顶层。
2.  最顶层的类加载器首先针对其特定的位置加载，如果加载不到就转交给子类。
3.  如果一直到底层的类加载都没有加载到，那么就会抛出异常ClassNotFoundException。

#### Tocmat类加载过程

web应用加载类：

1. 使用bootstrap引导类加载器加载


2. 使用system系统类加载器加载
3. 使用应用类加载器在WEB-INF/classes中加载
4. 使用应用类加载器在WEB-INF/lib中加载
5. 使用common类加载器在CATALINA_HOME/lib中加载

#### 页面间对象传递的方法

JSP页面之间的七种传参方法

1. 利用javaBean
2. 绑定到session对象
3. 绑定到application
4. 绑定到request
5. 使用JSP动作指令传参
6. 表单传参
7. URL传参

#### JSP九大内置对象的主要方法

1. request对象

   客户端的请求信息被封装在request对象中，它是HttpServletRequest类的实例。

   1   object getAttribute(String name) 返回指定属性的属性值 
   2   Enumeration getAttributeNames() 返回所有可用属性名的枚举 
   3   String getCharacterEncoding() 返回字符编码方式 
   4   int getContentLength() 返回请求体的长度（以字节数） 
   5   String getContentType() 得到请求体的MIME类型 
   6   ServletInputStream getInputStream() 得到请求体中一行的二进制流 
   7   String getParameter(String name) 返回name指定参数的参数值 
   8   Enumeration getParameterNames() 返回可用参数名的枚举 
   9   String[] getParameterValues(String name) 返回包含参数name的所有值的数组 
   10   String getProtocol() 返回请求用的协议类型及版本号 
   11   String getScheme() 返回请求用的计划名,如:http.https及ftp等 
   12   String getServerName() 返回接受请求的服务器主机名 
   13   int getServerPort() 返回服务器接受此请求所用的端口号 
   14   BufferedReader getReader() 返回解码过了的请求体 
   15   String getRemoteAddr() 返回发送此请求的客户端IP地址 
   16   String getRemoteHost() 返回发送此请求的客户端主机名 
   17   void setAttribute(String key,Object obj) 设置属性的属性值 
   18   String getRealPath(String path) 返回一虚拟路径的真实路径 

2. response对象

     response对象包含了响应客户请求的有关信息，它是HttpServletResponse类的实例。

   1   String getCharacterEncoding() 返回响应用的是何种字符编码 
   2   ServletOutputStream getOutputStream() 返回响应的一个二进制输出流 
   3   PrintWriter getWriter() 返回可以向客户端输出字符的一个对象 
   4   void setContentLength(int len) 设置响应头长度 
   5   void setContentType(String type) 设置响应的MIME类型 
   6   sendRedirect(java.lang.String location) 重新定向客户端的请求 

3. session对象

   session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.

   1   long getCreationTime() 返回SESSION创建时间 
   2   public String getId() 返回SESSION创建时JSP引擎为它设的惟一ID号 
   3   long getLastAccessedTime() 返回此SESSION里客户端最近一次请求时间 
   4   int getMaxInactiveInterval() 返回两次请求间隔多长时间此SESSION被取消(ms) 
   5   String[] getValueNames() 返回一个包含此SESSION中所有可用属性的数组 
   6   void invalidate() 取消SESSION，使SESSION不可用 
   7   boolean isNew() 返回服务器创建的一个SESSION,客户端是否已经加入 
   8   void removeValue(String name) 删除SESSION中指定的属性 
   9   void setMaxInactiveInterval() 设置两次请求间隔多长时间此SESSION被取消(ms) 

4. out对象

    out对象是JspWriter类的实例,是向客户端输出内容常用的对象

   1   void clear() 清除缓冲区的内容 
   2   void clearBuffer() 清除缓冲区的当前内容 
   3   void flush() 清空流 
   4   int getBufferSize() 返回缓冲区以字节数的大小，如不设缓冲区则为0 
   5   int getRemaining() 返回缓冲区还剩余多少可用 
   6   boolean isAutoFlush() 返回缓冲区满时，是自动清空还是抛出异常 
   7   void close() 关闭输出流 

5. page对象

    page对象就是指向当前JSP页面本身，有点像类中的this指针，它是java.lang.Object类的实例

   1   class getClass 返回此Object的类 
   2   int hashCode() 返回此Object的hash码 
   3   boolean equals(Object obj) 判断此Object是否与指定的Object对象相等 
   4   void copy(Object obj) 把此Object拷贝到指定的Object对象中 
   5   Object clone() 克隆此Object对象 
   6   String toString() 把此Object对象转换成String类的对象 
   7   void notify() 唤醒一个等待的线程 
   8   void notifyAll() 唤醒所有等待的线程 
   9   void wait(int timeout) 使一个线程处于等待直到timeout结束或被唤醒 
   10   void wait() 使一个线程处于等待直到被唤醒 
   11   void enterMonitor() 对Object加锁 
   12   void exitMonitor() 对Object开锁 

6. application对象

   application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。

   1   Object getAttribute(String name) 返回给定名的属性值 
   2   Enumeration getAttributeNames() 返回所有可用属性名的枚举 
   3   void setAttribute(String name,Object obj) 设定属性的属性值 
   4   void removeAttribute(String name) 删除一属性及其属性值 
   5   String getServerInfo() 返回JSP(SERVLET)引擎名及版本号 
   6   String getRealPath(String path) 返回一虚拟路径的真实路径 
   7   ServletContext getContext(String uripath) 返回指定WebApplication的application对象 
   8   int getMajorVersion() 返回服务器支持的Servlet API的最大版本号 
   9   int getMinorVersion() 返回服务器支持的Servlet API的最小版本号 
   10   String getMimeType(String file) 返回指定文件的MIME类型 
   11   URL getResource(String path) 返回指定资源(文件及目录)的URL路径 
   12   InputStream getResourceAsStream(String path) 返回指定资源的输入流 
   13   RequestDispatcher getRequestDispatcher(String uripath) 返回指定资源的RequestDispatcher对象 
   14   Servlet getServlet(String name) 返回指定名的Servlet 
   15   Enumeration getServlets() 返回所有Servlet的枚举 
   16   Enumeration getServletNames() 返回所有Servlet名的枚举 
   17   void log(String msg) 把指定消息写入Servlet的日志文件 
   18   void log(Exception exception,String msg) 把指定异常的栈轨迹及错误消息写入Servlet的日志文件 
   19   void log(String msg,Throwable throwable) 把栈轨迹及给出的Throwable异常的说明信息 写入Servlet的日志文件 

7. exception对象

   exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象

   1   String getMessage() 返回描述异常的消息 
   2   String toString() 返回关于异常的简短描述消息 
   3   void printStackTrace() 显示异常及其栈轨迹 
   4   Throwable FillInStackTrace() 重写异常的执行栈轨迹 

8. pageContext对象

   pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本类名也叫pageContext。

   1   JspWriter getOut() 返回当前客户端响应被使用的JspWriter流(out) 
   2   HttpSession getSession() 返回当前页中的HttpSession对象(session) 
   3   Object getPage() 返回当前页的Object对象(page) 
   4   ServletRequest getRequest() 返回当前页的ServletRequest对象(request) 
   5   ServletResponse getResponse() 返回当前页的ServletResponse对象(response) 
   6   Exception getException() 返回当前页的Exception对象(exception) 
   7   ServletConfig getServletConfig() 返回当前页的ServletConfig对象(config) 
   8   ServletContext getServletContext() 返回当前页的ServletContext对象(application) 
   9   void setAttribute(String name,Object attribute) 设置属性及属性值 
   10   void setAttribute(String name,Object obj,int scope) 在指定范围内设置属性及属性值 
   11   public Object getAttribute(String name) 取属性的值 
   12   Object getAttribute(String name,int scope) 在指定范围内取属性的值 
   13   public Object findAttribute(String name) 寻找一属性,返回其属性值或NULL 
   14   void removeAttribute(String name) 删除某属性 
   15   void removeAttribute(String name,int scope) 在指定范围删除某属性 
   16   int getAttributeScope(String name) 返回某属性的作用范围 
   17   Enumeration getAttributeNamesInScope(int scope) 返回指定范围内可用的属性名枚举 
   18   void release() 释放pageContext所占用的资源 
   19   void forward(String relativeUrlPath) 使当前页面重导到另一页面 
   20   void include(String relativeUrlPath) 在当前位置包含另一文件 

9. config对象

    config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）

   1   ServletContext getServletContext() 返回含有服务器相关信息的ServletContext对象 
   2   String getInitParameter(String name) 返回初始化参数的值 
   3   Enumeration getInitParameterNames() 返回Servlet初始化所需所有参数的枚举 

#### Get和Post的区别

1. get是从服务器上获取数据，post是向服务器传送数据。 
2. get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。 
3. 对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据

> GET后退按钮/刷新无害，POST数据会被重新提交（浏览器应该告知用户数据会被重新提交）。
> GET书签可收藏，POST为书签不可收藏。
> GET能被缓存，POST不能缓存 。
> GET编码类型application/x-www-form-url，POST编码类型encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。
> GET历史参数保留在浏览器历史中。POST参数不会保存在浏览器历史中。
> GET对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。POST无限制。
> GET只允许 ASCII 字符。POST没有限制。也允许二进制数据。
> 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。
> GET的数据在 URL 中对所有人都是可见的。POST的数据不会显示在 URL 中

**重大区别** 

GET产生一个TCP数据包；POST产生两个TCP数据包。

对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

GET的语义是请求获取指定的资源。GET方法是安全、幂等、可缓存的（除非有 Cache-ControlHeader的约束）,GET方法的报文主体没有任何语义。

POST的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST不安全，不幂等，（大部分实现）不可缓存。

#### 转发和重定向的区别

**调用方式** 

- servlet

```
request.getRequestDispatcher("new.jsp").forward(request, response);   //转发到new.jsp
response.sendRedirect("new.jsp");   //重定向到new.jsp
```

- Jsp

```
<jsp:forward page="apage.jsp" />   //转发
<%response.sendRedirect("new.jsp"); %> //重定向到new.jsp
```

**本质**： 

转发是服务器行为，重定向是客户端行为

> 转发过程：客户浏览器发送http请求——》web服务器接受此请求——》调用内部的一个方法在容器内部完成请求处理和转发动作——》将目标资源发送给客户；在这里，转发的路径必须是同一个web容器下的url，其不能转向到其他的web路径上去，中间传递的是自己的容器内的request。在客户浏览器路径栏显示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。
>
> 请求转发是服务器内部把对一个request/response的处理权，移交给另外一个
>
> 对于客户端而言，它只知道自己最早请求的那个A，而不知道中间的B，甚至C、D。传输的信息不会丢失。

> 重定向过程：客户浏览器发送http请求——》web服务器接受后发送302状态码响应及对应新的location给客户浏览器——》客户浏览器发现是302响应，则**自动**再发送一个新的http请求，请求url是新的location地址——》服务器根据此请求寻找资源并发送给客户。在这里location可以重定向到任意URL，既然是浏览器重新发出了请求，则就没有什么request传递的概念了。在客户浏览器路径栏显示的是其重定向的路径，客户可以观察到地址的变化的。重定向行为是浏览器做了至少两次的访问请求的。
>
> 重定向，其实是两次request
>
> 第一次，客户端request   A,服务器响应，并response回来，告诉浏览器，你应该去B。这个时候IE可以看到地址变了，而且历史的回退按钮也亮了。重定向可以访问自己web应用以外的资源。在重定向的过程中，传输的信息会被丢失。

**区别**：

- 重定向时浏览器的网址改变，转发是浏览器上的网址不变
- 重定向实际上产生了两次请求，转发只有一次请求
- 重定向时的网址可以是任何网址，转发的网址必须是本站点的网址
- 重定向：以前的request中存放的变量全部失效，并进入一个新的request作用域。转发：以前的request中存放的变量不会失效，就像把两个页面拼到了一起。

## SQL

#### 如何让sql使用指定的索引

select * from tabel with(指定索引名)

或  select * from tabel with(INDEX =指定索引名)

#### 位图索引

**位图索引**是一种使用[位图](https://baike.so.com/doc/630856-667651.html)的特殊数据库索引。

主要针对大量相同值的列而创建(例如:类别，操作员，部门ID,库房ID等),索引块的一个索引行中存储键值和起止Rowid,以及这些键值的位置编码,

位置编码中的每一位表示键值对应的数据行的有无.一个块可能指向的是几十甚至成百上千行数据的位置.这种方式存储数据,相对于B*Tree索引,占用的空间非常小,创建和使用非常快.

当根据键值查询时,可以根据起始Rowid和位图状态,快速定位数据.

当根据键值做and,or或 in(x,y,..)查询时,直接用索引的位图进行或运算,快速得出结果行数据.

当select count(XX) 时,可以直接访问索引就快速得出统计数据.

```
创建语法
create bitmap index ssex_bitmap_index on zhou.student(ssex) 
tablespace MYSPACE; 
```

##### 位图索引的优势和不适合使用的场景

优势：

1. 位图索引使用于低基数的列，相对于B树索引，它的count,and,or操作更有效
2. 位图索引存放的是0,1的比特位，相对于B树索引，占字节数特别少?

不适用场景：

1. 列的基数比较多，不适合位图索引，因为它会占用更多的存储空间
2. 索引列DML频繁的列，不适合位图索引，容易造成死锁?

#### 索引的作用？它的优点缺点是什么？

索引就一种特殊的查询表，数据库的搜索可以利用它加速对数据的检索。索引可以是唯一的，创建索引允许指定单个列或者是多个列。缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。一般唯一、不为空、经常被查询的字段适合建索引

MySQL数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引

**优点：** 

- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性
- 可以大大加快数据的检索速度，这也是创建索引的最主要的原因
- 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义
- 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间
- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能

**缺点：** 

- 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加
- 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大
- 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度

#### 什么样的字段适合建索引？

- 总的来说就是数据量大的，经常进行查询操作的表要建立索引
- 表中字段建立索引应该遵循几个原则：
  1. 越小的数据类型通常更好：越小的数据类型通常在磁盘、内存中都需要更少的空间，处理起来更快
  2. 简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂，处理起来也更耗时
  3. 尽量避免NULL：应该指定列为NOT NULL。含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值
  4. 索引的建立应当更多的选取唯一性更高的字段
- 表与表连接用于多表联合查询的约束条件的字段应当建立索引
- 用于排序的字段可以添加索引，用于分组的字段应当视情况看是否需要添加索引
- 添加多列索引的时候，对应的多条件查询可以触发该索引的同时，索引最左侧的列的单条件查询也可以触发
- 如果有些表注定只会进行查询所有，也就没必要添加索引，因为查询全部只能进行全量搜索即扫描全表

##### 不应该创建索引的的这些列具有下列特点:

1. 对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 
2. 对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 
3. 对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 
4. 当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。

#### 创建索引的方法和索引的特征

创建索引有多种方法，这些方法包括直接创建索引的方法和间接创建索引的方法。直接创建索引，例如使用CREATE INDEX语句或者使用创建索引向导，间接创建索引，例如在表中定义主键约束或者唯一性键约束时，同时也创建了索引。虽然，这两种方法都可以创建索引，但 是，它们创建索引的具体内容是有区别的。 

> 使用CREATE INDEX语句或者使用创建索引向导来创建索引，这是最基本的索引创建方式，并且这种方法最具有柔性，可以定制创建出符合自己需要的索引。在使用这种方式 创建索引时，可以使用许多选项，例如指定数据页的充满度、进行排序、整理统计信息等，这样可以优化索引。使用这种方法，可以指定索引的类型、唯一性和复合 性，也就是说，既可以创建聚簇索引，也可以创建非聚簇索引，既可以在一个列上创建索引，也可以在两个或者两个以上的列上创建索引。 

> 通过定义主键约束或者唯一性键约束，也可以间接创建索引。主键约束是一种保持数据完整性的逻辑，它限制表中的记录有相同的主键记录。在创建主键约束时，系 统自动创建了一个唯一性的聚簇索引。虽然，在逻辑上，主键约束是一种重要的结构，但是，在物理结构上，与主键约束相对应的结构是唯一性的聚簇索引。换句话说，在物理实现上，不存在主键约束，而只存在唯一性的聚簇索引。同样，在创建唯一性键约束时，也同时创建了索引，这种索引则是唯一性的非聚簇索引。因此，当使用约束创建索引时，索引的类型和特征基本上都已经确定了，由用户定制的余地比较小。 

主键约束或者唯一性键约束创建的索引的优先级高于使用CREATE INDEX语句创建的索引。 

**索引有两个特征，即唯一性索引和复合索引**

> 唯一性索引保证在索引列中的全部数据是唯一的，不会包含冗余数据。如果表中已经有一个主键约束或者唯一性键约束，那么当创建表或者修改表时，SQL Server自动创建一个唯一性索引。然而，如果必须保证唯一性，那么应该创建主键约束或者唯一性键约束，而不是创建一个唯一性索引。当创建唯一性索引 时，应该认真考虑这些规则：当在表中创建主键约束或者唯一性键约束时，SQL Server自动创建一个唯一性索引；如果表中已经包含有数据，那么当创建索引时，SQL Server检查表中已有数据的冗余性；每当使用插入语句插入数据或者使用修改语句修改数据时，SQL Server检查数据的冗余性：如果有冗余值，那么SQL Server取消该语句的执行，并且返回一个错误消息；确保表中的每一行数据都有一个唯一值，这样可以确保每一个实体都可以唯一确认；只能在可以保证实体 完整性的列上创建唯一性索引，例如，不能在人事表中的姓名列上创建唯一性索引，因为人们可以有相同的姓名。 

> 复合索引就是一个索引创建在两个列或者多个列上。在搜索时，当两个或者多个列作为一个关键值时，最好在这些列上创建复合索引。当创建复合索引时，应该考虑 这些规则：最多可以把16个列合并成一个单独的复合索引，构成复合索引的列的总长度不能超过900字节，也就是说复合列的长度不能太长；在复合索引中，所 有的列必须来自同一个表中，不能跨表建立复合列；在复合索引中，列的排列顺序是非常重要的，因此要认真排列列的顺序，原则上，应该首先定义最唯一的列，例 如在（COL1，COL2）上的索引与在（COL2，COL1）上的索引是不相同的，因为两个索引的列的顺序不同；为了使查询优化器使用复合索引，查询语 句中的WHERE子句必须参考复合索引中第一个列；当表中有多个关键列时，复合索引是非常有用的；使用复合索引可以提高查询性能，减少在一个表中所创建的索引数量。

#### 使用索引查询一定能提高查询的性能吗？为什么？

1. 表存储量，超过百万，查询效率会明显降低。
2. 索引类型。虽然增加索引可以增加查询效率，可是过多，会略影响性能，而且索引字段的类型，也影响查询性能，int性能是最好的，字符类型的索引查询性能略差
3. 表存储类型影响性能，有innodb myisam 等类型

#### mysql的三大引擎是啥？

简单来说，存储引擎就是指**表的类型以及表在计算机上的存储方式**。

存储引擎的概念是MySQL的特点，Oracle中没有专门的存储引擎的概念，Oracle有OLTP和OLAP模式的区分。不同的存储引擎决定了MySQL数据库中的表可以用不同的方式来存储。我们可以根据数据的特点来选择不同的存储引擎。

在MySQL中的存储引擎有很多种，可以通过“SHOW ENGINES”语句来查看。主要由InnoDB、MyISAM、MEMORY这三种。

- MYISAM ： 全表锁，拥有较高的执行速度，一个写请求请阻塞另外相同表格的所有读写请求，并发性能差，占用空间相对较小，mysql 5.5 及以下仅 MYISAM 支持全文索引，不支持事务。
- Innodb ： 行级锁（SQL 都走索引查询），并发能力相对强，占用空间是 MYISAM 的 2.5 倍，不支持全文索引（5.6 开始支持），支持事务。
- Memory ： 全表锁，存储在内存当中，速度快，但会占用和数据量成正比的内存空间且数据在 mysql 重启时会丢失。

[参考](http://www.cnblogs.com/yuxiuyan/p/6511837.html)

#### 索引类型有哪些？

逻辑上：

- Single column 单行索引
- Concatenated 多行索引
- Unique 唯一索引
- NonUnique 非唯一索引
- Function-based 函数索引
- Domain 域索引

物理上：

- Partitioned 分区索引
- NonPartitioned 非分区索引

B-tree:

- Normal 正常型B树
- Rever Key 反转型B树
- Bitmap 位图索引

##### Mysql数据库索引类型

mysql 有四种不同的索引类型：

- 主键索引 ( PRIMARY )
- 唯一索引 ( UNIQUE )
- 普通索引 ( INDEX )
- 全文索引（FULLTEXT , MYISAM 及 mysql 5.6 以上的 Innodb ）

建立索引的目的是加快对表中记录的查找或排序，索引也并非越多越好，因为创建索引是要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间维护索引。

#### 索引的原理，索引底层用什么实现的?

索引的原理大致概括为以空间换时间，数据库在未添加索引的时候进行查询默认的是进行全量搜索，也就是进行全局扫描，有多少条数据就要进行多少次查询，然后找到相匹配的数据就把他放到结果集中，直到全表扫描完。而建立索引之后，会将建立索引的KEY值放在一个n叉树上(BTree)。因为B树的特点就是适合在磁盘等直接存储设备上组织动态查找表，每次以索引进行条件查询时，会去树上根据key值直接进行搜索，次数约为log总条数，底数为页面存储数，例如一个100万数据的表，页面存储数为100，那么有索引的查询次数为3次log1000000100，但是全量搜索为100万次搜索，这种方式类似于二分法，但是这个是n分法。

MySQL支持多种索引类型，如BTree索引，哈希索引，全文索引等待

MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。

索引的实现通常使用B树及其变种B+树。

原理：通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。

> B树事实上是一种平衡的多叉查找树，也就是说最多可以开m个叉（m>=2）
>
> m阶B树满足以下条件：
>
> - 每个节点至多可以拥有m棵子树。
> - 根节点，只有至少有2个节点（要么极端情况，就是一棵树就一个根节点，单细胞生物，即是根，也是叶，也是树)。
> - 非根非叶的节点至少有的Ceil(m/2)个子树(Ceil表示向上取整)。
> - 非叶节点中的信息包括[n,A0,K1,A1,K2,A2,…,Kn,An]，，其中n表示该节点中保存的关键字个数，K为关键字且Ki<Ki+1，A为指向子树根节点的指针。
> - 从根到叶子的每一条路径都有相同的长度，也就是说，叶子节在相同的层，并且这些节点不带信息，实际上这些节点就表示找不到指定的值，也就是指向这些节点的指针为空。
>
> B树的特点
>
> - 关键字集合分布在整颗树中。
> - 任何一个关键字出现且只出现在一个节点中。
> - 搜索有可能在非叶子节点结束。
> - 其搜索性能等价于在关键字集合内做一次二分查找。
> - B树在插入删除新的数据记录会破坏B-Tree的性质，因为在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质。

> 作为B树的加强版，B+树与B树的差异在于:
>
> - 有n棵子树的节点含有n个关键字（也有认为是n-1个关键字）。
> - 所有的关键字全部存储在叶子节点上，且叶子节点本身根据关键字自小而大顺序连接。
> - 非叶子节点可以看成索引部分，节点中仅含有其子树（根节点）中的最大（或最小）关键字。
>
> B+树的查找过程，与B树类似，只不过查找时，如果在非叶子节点上的关键字等于给定值，并不终止，而是继续沿着指针直到叶子节点位置。因此在B+树，不管查找成功与否，每次查找都是走了一条从根到叶子节点的路径。
>
> B+树的特性如下：
>
> - 所有关键字都存储在叶子节上，且链表中的关键字恰好是有序的。
> - 不可能非叶子节点命中返回。
> - 非叶子节点相当于叶子节点的索引，叶子节点相当于是存储（关键字）数据的数据层。
> - 更适合文件索引系统。
>
> 一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。做这个优化的目的是为了提高区间访问的性能.

##### MySQL为什么使用B树（B+树）

一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。

在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的.

MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。

**在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的：**

MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。

虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。

#### 在数据库中查询语句速度很慢，如何优化？

1. 建索引
2. 减少表之间的关联 
3. 优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引,把数据 量大的表排在前面
4. 简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据
5. 尽量用PreparedStatement来查询，不要用Statement

#### 什么是存储过程？有哪些优缺点？

存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。 调用： 1）可以用一个命令对象来调用存储过程。 2）可以供外部程序调用，比如：java程序。

**优点**

- 存储过程是预编译过的，执行效率高。 
- 存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。 
- 安全性高，执行存储过程需要有一定权限的用户。
- 存储过程可以重复使用，可减少数据库开发人员的工作量。

**缺点**

- 移植性差

##### 存储过程与函数的区别

| 存储过程                        | 函数                                       |
| :-------------------------- | :--------------------------------------- |
| 用于在数据库中完成特定的操作或者任务（如插入、删除等） | 用于特点的数据（如选择）                             |
| 程序头部声明用procedure            | 程序头部声明用function                          |
| 程序头部声明时不需描述返回类型             | 程序头部声明时要描述返回类型，二期PL/SQL至少要包括一个有效的return语句 |
| 可以使用in/out/in out 三种模式的参数   | 可以使用in/out/in out 三种模式的参数                |
| 可作为一个独立的PL/SQL语句来执行         | 不能独立执行，必须作为表达式的一部分调用                     |
| 可以通过out/in out返回零个或多个值      | 通过return语句返回一个值，且该值要与声明部分一致，也可以是通过out类型的参数带出的变量 |
| SQL语句（DML或SELECT）中不可调用存储过程  | SQL语句（DML或SELECT）中可以调用存储过程               |

#### 什么是触发器？

触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。

#### 什么是事务？

事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。

#### 什么是锁？

锁：在所以的DBMS中，锁是实现事务的关键，锁可以保证事务的完整性和并发性。与现实生活中锁一样，它可以使某些数据的拥有者，在某段时间内不能使用某些数据或数据结构。当然锁还分级别的。

##### 乐观锁和悲观锁是什么？

###### 乐观锁

乐观并发控制（又名”乐观锁”，Optimistic Concurrency Control，缩写”OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。

**乐观并发控制的阶段**

1. 读取：事务将数据读入缓存，这时系统会给事务分派一个时间戳。 
2. 校验：事务执行完毕后，进行提交。这时同步校验所有事务，如果事务所读取的数据在读取之后又被其他事务修改，则产生冲突，事务被中断回滚。 
3. 写入：通过校验阶段后，将更新的数据写入数据库。

> 乐观并发控制多数用于数据争用不大、冲突较少的环境中，这种环境中，偶尔回滚事务的成本会低于读取数据时锁定数据的成本，因此可以获得比其他并发控制方法更高的吞吐量。
>
> 相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。
>
> 数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判 断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过 期数据。

**实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。**

- 使用版本号实现乐观锁

  *使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。*

> 优势与不足
>
> 　　乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。但如果直接简单这么做，还是有可能会遇到不可预 期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。

###### 悲观锁

在关系数据库管理系统里，悲观并发控制（又名”悲观锁”，Pessimistic Concurrency Control，缩写”PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作读某行数据应用了 锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。

> 悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。

MySQL InnoDB中使用悲观锁:

​	要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为**MySQL默认使用autocommit模式**，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。`set autocommit=0;`

**MySQL InnoDB默认行级锁**。**行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。** 

> 优势与不足
>
> ​	悲观并发控制实际上是”先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增 加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数 据，其他事务就必须等待该事务处理完才可以处理那行数

**乐观锁不是数据库自带的，需要我们自己去实现。悲观锁是由数据库自己实现了的。**

共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。

###### 共享锁 

共享锁指的就是对于多个不同的事务，对同一个资源共享同一个锁。

通过在执行语句后面加上lock in share mode就代表对某些资源加上共享锁了。

###### 排他锁

排它锁与共享锁相对应，就是指对于多个不同的事务，对同一个资源只能有一把锁。

与共享锁类似，在需要执行的语句后面加上for update就可以了

###### 行锁

行锁，由字面意思理解，就是给某一行加上锁，也就是一条记录加上锁。

###### 表锁

表锁，和行锁相对应，给这个表加上锁。

#### 什么叫视图？游标是什么？

视图：是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。

游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。

##### 视图的优缺点

优点:

1. 对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。
2. 用户通过简单的查询可以从复杂查询中得到结果。
3. 维护数据的独立性，试图可从多个表检索数据。
4. 对于相同的数据可产生不同的视图。

缺点：

​    性能：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，那么就无法更改数据

#### 数据库三范式是什么?

- 第一范式：列不可再分
- 第二范式：行可以唯一区分，主键约束
- 第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束

三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上

#### 什么是sql注入？

所谓SQL注入式攻击，就是攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串，**欺骗服务器执行恶意的SQL命令**。在某些表单中，用户输入的内容直接用来构造（或者影响）动态SQL命令，或作为存储过程的输入参数，这类表单特别容易受到SQL注入式攻击。

#### **如何防范SQL注入式攻击？**

1. 对于动态构造SQL查询的场合，可以使用下面的技术：
   - **替换单引号，即把所有单独出现的单引号改成两个单引号，防止攻击者修改SQL命令的含义**。
   - **删除用户输入内容中的所有连字符**
   - **对于用来执行查询的数据库帐户，限制其权限**。**用不同的用户帐户执行查询、插入、更新、删除操作**。
2. **用存储过程来执行所有的查询。**
3. **限制表单或查询字符串输入的长度**。
4. **检查用户输入的合法性**
5. **将用户登录名称、密码等数据加密保存**
6. **检查提取数据的查询所返回的记录数量。**

#### Oracle和Mysql的区别？

1. 库函数不同。
2. Oracle是用表空间来管理的，Mysql不是
3. 显示当前所有的表、用户、改变连接用户、显示当前连接用户、执行外部脚本的语句的不同。
4. 分页查询时候时候，mysql用limit oracle用rownum

#### 常见的sql优化

- 避免在where子句中使用 is null 或 is not null 对字段进行判断
- 避免在 where 子句中使用 != 或 <> 操作符
- 避免在 where 子句中使用 or来链接条件
- 少用 in 或 not in
- 注意 like 中通配符的使用
- 避免在 where 子句中对字段进行表达式操作
- 避免在 where 子句中对字段进行函数操作
- 在where语句或者order by 语句中避免对索引字段进行计算操作
- 在子查询中，用 exists 代替 in 是一个好的选择
- 通过变量的方式来设置参数
- 不要使用select *
- 不要使用列号
- 优先使用UNION ALL,避免使用UNION
- 复杂操作可以考虑适当拆成几步
- 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 
- 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要
- 应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 
- 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 
- 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 
- 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。
- 避免频繁创建和删除临时表，以减少系统表资源的消耗。 
- 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 
- 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 
- 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 
- 在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。 
- 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 
- 尽量避免大事务操作，提高系统并发能力。

**参考：**  [1](https://blog.csdn.net/csdnstudent/article/details/40398245)        [2](https://www.jb51.net/article/111015.htm) 

#### 如何处理慢查询

打开慢查询日志,linux下打开需在my.cnf的[mysqld]里面加上以下内容：

```
slow_query_log=TRUE(有些mysql版本是ON)
slow_query_log_file=/usr/local/mysql/slow_query_log.txt
long_query_time=3
```

Windows下，在my.ini配置文件的[mysqld]选项下增加：

```
slow_query_log=TRUE
slow_query_log_file=c:/slow_query_log.txt
long_query_time=3
```

添加完成之后记得一定要重启mysql服务才能生效记录输出。最后在MySQL客户端中输入命令：

show variables like '%quer%'; 核查一下是否更改成功。

查看配置：

```
//查看慢查询时间
show variables like "long_query_time";默认10s
//查看慢查询配置情况
show status like "%slow_queries%";
//查看慢查询日志路径
 show variables like "%slow%";
```

-slow_query_log是否记录慢查询。用long_query_time变量的值来确定“慢查询”。

-slow_query_log_file慢日志文件路径

-long_query_time慢日志执行时长（秒），超过设定的时间才会记日志

**补充**

查看正在锁的事务        SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS; 

查看等待锁的事务        SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS; 

查看服务器状态            show status like ‘%lock%’

查看当前有那些表是打开的     show open tables;   

​	In_use列表示有多少线程正在使用某张表，Name_locked表示表名是否被锁，这一般发生在Drop或Rename命令操作这张表时。

查看Innodb引擎状态信息     show engine innodb status;

[由SQL编写导致的慢查询](https://mp.weixin.qq.com/s?__biz=MjM5NzMyMjUwMg==&mid=2247485578&idx=1&sn=378ccdb141b5f3f9bf8a53c01303d19e&chksm=a6da82e391ad0bf58e5dc6e8f2fed7d58697cd28463cb69f5030c1f507fa5ca6ffc717899dee&scene=0&xtrack=1#rd) 

#### 数据库挂了怎么办？

[处理数据库异常挂掉](https://www.jianshu.com/p/e88f89bc9229)

##### 数据库锁表怎么办？

-- 查看那些表锁到了
show OPEN TABLES where In_use > 0;
-- 查看进程号
show processlist;  或者 show full processlist;
--删除进程
 kill 1085850；

**或者**

UNLOCK TABLES;

#### 主从复制

[mysql主从复制的步骤](https://www.aliyun.com/jiaocheng/1105672.html?spm=5176.100033.9.13.2075235f7JpNUG)

#### 什么影响了 MySQL 性能？

1. 影响性能的几个因素

   - 服务器硬件。
   - 服务器系统（系统参数优化）。
   - **存储引擎**。
     `MyISAM`： 不支持事务，表级锁。
     `InnoDB`: 支持事务，支持行级锁，事务`ACID`。
   - **数据库参数配置。**
   - **数据库结构设计和SQL语句。（重点优化）**

2. Mysql体系结构

   **分三层：客户端->服务层->存储引擎**

   ![](https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfe39A5picdNfpqh5RI8Hlk8Tg1rcESjpNLUyACgILhlXZ5Dby26z88ZOQ9d65bPOXUDpfyVVAJkBTQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

   - `MySQL`是**插件式的存储引擎**，其中存储引擎分很多种。只要实现符合mysql存储引擎的接口，可以开发自己的存储引擎!
   - 所有跨存储引擎的功能都是在服务层实现的。
   - MySQL的**存储引擎是针对表的，不是针对库的**。也就是说在一个数据库中可以使用不同的存储引擎。但是不建议这样做。

3. InnoDB存储引擎及其特性

   MySQL5.5`及之后版本默认的存储引擎：`InnoDB

   InnoDB使用表空间进行数据存储。

   ```
   show variables like 'innodb_file_per_table'
   ```

   innodb_file_per_table 为 ON 将建立独立的表空间，文件为tablename.ibd；innodb_file_per_table 为 OFF 将数据存储到系统的共享表空间，文件为ibdataX（X为从1开始的整数）；

   `.frm` ：是服务器层面产生的文件，类似服务器层的数据字典，记录表结构。

   ​:arrow_forward: 系统表空间（mysql5.5默认）与独立表空间（mysql5.6及以后默认）区别

   - 系统表空间无法简单的收缩文件大小，造成空间浪费，并会产生大量的磁盘碎片。
   - 独立表空间可以通过`optimeze table` 收缩系统文件，不需要重启服务器也不会影响对表的正常访问。
   - 如果对多个表进行刷新时，实际上是顺序进行的，会产生IO瓶颈。
   - 独立表空间可以同时向多个文件刷新数据。

   因此**强烈建立对Innodb 使用独立表空间**

   **特性**

   - 事务性存储引擎及两个特殊日志类型：Redo Log 和 Undo Log

     1. Innodb是一种事务性存储引擎
     2. 完全支持事物的ACID特性
     3. 支持事务所需要的两个特殊日志类型：Redo Log 和 Undo Log

     Redo Log : 实现事务的持久性（已提交的事务）

     Undo Log :未提交的事务，独立于表空间，需要随机访问，可以存储在高性能io设备上。

   - 支持行级锁

     1. InnoDB支持行级锁。
     2. 行级锁可以最大程度地支持并发。
     3. 行级锁是由存储引擎层实现的。

4. 锁

   > - 锁主要作用是管理共享资源的并发访问
   > - 锁用于实现事务的隔离性

   锁分为共享锁（读锁）和独占锁（写锁），除了读锁与读锁之间可以兼容外，其他两两都不兼容。

   MySQL的事务支持**不是绑定在MySQL服务器本身**，**而是与存储引擎相关**

   按照粒度，可以分为表级锁和行级锁。

   > 将**table_name**加表级锁命令：`lock table table_name write`; **写锁会阻塞其它用户对该表的‘读写’操作，直到**写锁被释放：`unlock tables`。

   1. **锁的开销越大，粒度越小，并发度越高。**
   2. 表级锁通常是在服务器层实现的。
   3. 行级锁是存储引擎层实现的。innodb的锁机制，服务器层是不知道的

   **阻塞和死锁**

   - 阻塞是由于资源不足引起的排队等待现象。
   - 死锁是由于两个对象在拥有一份资源的情况下申请另一份资源，而另一份资源恰好又是这两对象正持有的，导致两对象无法完成操作，且所持资源无法释放。

5. 选择正确的存储引擎

需要参考：

- 事务
- 备份（`Innobd`免费在线备份）
- 崩溃恢复
- 存储引擎的特有特性

总结：最好使用InnoDB引擎。 尽量别使用混合存储引擎，比如回滚会出问题在线热备问题。

6. 内存配置参数

   - 确定可以使用的内存上限。

     > 内存的使用上限不能超过物理内存，否则容易造成内存溢出；（对于32位操作系统，MySQL只能试用3G以下的内存。）

   - 确定MySQL的**每个连接单独**使用的内存。

     - sort_buffer_size #定义了每个线程排序缓存区的大小，MySQL在有查询、需要做排序操作时才会为每个缓冲区分配内存（直接分配该参数的全部内存）；

     - join_buffer_size #定义了每个线程所使用的连接缓冲区的大小，如果一个查询关联了多张表，MySQL会为每张表分配一个连接缓冲，导致一个查询产生了多个连接缓冲；

     - read_buffer_size #定义了当对一张MyISAM进行全表扫描时所分配读缓冲池大小，MySQL有查询需要时会为其分配内存，其必须是4k的倍数；

     - read_rnd_buffer_size #索引缓冲区大小，MySQL有查询需要时会为其分配内存，只会分配需要的大小。

       **注意**  以上四个参数是为一个线程分配的，如果有100个连接，那么需要×100。

     总内存 -（每个线程所需要的内存*连接数）= 系统保留内存

   - MySQL数据库实例：

      MySQL是**单进程多线程**（而oracle是多进程），也就是说`MySQL`实例在系统上表现就是一个服务进程，即进程；MySQL实例是线程和内存组成，实例才是真正用于操作数据库文件的；**一般情况下**一个实例操作一个或多个数据库；**集群情况下**多个实例操作一个或多个数据库。

     **如何为缓存池分配内存：**

     -  `Innodb_buffer_pool_size`，定义了Innodb所使用缓存池的大小，对其性能十分重要，必须足够大，但是过大时，使得Innodb 关闭时候需要更多时间把脏页从缓冲池中刷新到磁盘中；

     -  `key_buffer_size`，定义了MyISAM所使用的缓存池的大小，由于数据是依赖存储操作系统缓存的，所以要为操作系统预留更大的内存空间；

       **注意：** 即使开发使用的表全部是Innodb表，也要为MyISAM预留内存，因为MySQL系统使用的表仍然是MyISAM表。

       `max_connections` 控制允许的最大连接数， 一般2000更大。

       **不要使用外键约束保证数据的完整性。**

7. 性能优化顺序

   优先级：（从上到下）

   - 数据库结构设计和SQL语句
   - 数据库存储引擎的选择和参数设置
   - 系统选择及优化
   - 硬件升级

#### 什么影响了数据库查询速度？

![](https://mmbiz.qpic.cn/mmbiz_png/tuSaKc6SfPoPbUQbsk6d95CNIgPM0WSXIJM12yrh3ZFMibtsHRhkeeNnzL9v7gpyjdYMpDktgTlypF9mCxagL3Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

> **QPS：**`Queries Per Second`意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。
>
> **TPS：**是`TransactionsPerSecond`的缩写，也就是事务数/秒。它是软件测试结果的测量单位。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。

**Tips：**最好不要在主库上数据库备份，大型活动前取消这样的计划。

风险：

1. 效率低下的`sql`：超高的`QPS`与`TPS`。
2. 大量的并发：数据连接数被占满（`max_connection`默认`100`，一般把连接数设置得大一些）。并发量:同一时刻数据库服务器处理的请求数量
3. 超高的`CPU`使用率：`CPU`资源耗尽出现宕机。
4. 磁盘`IO`：磁盘`IO`性能突然下降、大量消耗磁盘性能的计划任务。解决：更快磁盘设备、调整计划任务、做好磁盘维护。

网卡流量：如何避免无法连接数据库的情况

- 减少从服务器的数量（从服务器会从主服务器复制日志）
- 进行分级缓存（避免前端大量缓存失效）
- 避免使用`select *` 进行查询
- 分离业务网络和服务器网络

大表带来的问题：

> 大表特点：记录行数巨大，单表超千万；表数据文件巨大，超过`10`个`G`

​	大表的危害：

 1.  慢查询：**很难在短时间内过滤出需要的数据**  

  2. 对`DDL`影响：

   **建立索引需要很长时间：** 

   > - `MySQL -v<5.5` 建立索引会锁表
   > - `MySQL -v>=5.5` 建立索引会造成主从延迟（`mysql`建立索引，先在主库上执行，再在从库上执行） 

    **修改表结构需要长时间的锁表：**会造成长时间的主从延迟('480秒延迟')

  解决： 分库分表

大事务带来的问题：

> 1. 事务是数据库系统区别于其他一切文件系统的重要特性之一
> 2. 事务是一组具有原子性的SQL语句，或是一个独立的工作单元

事务的ACID特性

原子性（atomicity）  一致性（consistent） 隔离性（isolation）  持久性（DURABILITY）

事务的隔离级别：

- 未提交读(`READ UNCOMMITED`) **脏读**,两个事务之间互相可见；
- 已提交读(`READ COMMITED`)符合隔离性的基本概念,一个事务进行时，其它已提交的事物对于该事务是可见的，即可以获取其它事务提交的数据。
- 可重复读(`REPEATABLE READ`) **InnoDB的默认隔离等级**。事务进行时，其它所有事务对其不可见，即多次执行读，得到的结果是一样的！
- 可串行化（`SERIALIZABLE`） 在读取的每一行数据上都加锁，会造成大量的锁超时和锁征用，严格数据一致性且没有并发是可使用。

![](https://mmbiz.qpic.cn/mmbiz_png/tuSaKc6SfPoPbUQbsk6d95CNIgPM0WSX42p1z2Aia765cE4ohDkTDsokdhEeGib9ciaafqUe4gHiac3MGk1UykqRqQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

*`redo log`机制保证事务更新的一致性和持久性*

大事务危害：

运行时间长，操作数据比较多的事务；

**风险：锁定数据太多，回滚时间长，执行时间长。**

- 锁定太多数据，造成大量阻塞和锁超时；
- 回滚时所需时间比较长，且数据仍然会处于锁定；
- 如果执行时间长，将造成主从延迟，因为只有当主服务器全部执行完写入日志时，从服务器才会开始进行同步，造成延迟。

解决：

- 避免一次处理太多数据，可以分批次处理；
- 移出不必要的`SELECT`操作，保证事务中只有必要的写操作。

#### Mysql性能优化

```
show status    //查看 MySQL 服务器运行的状态值
```

​:arrow_forward:  主要关注“Queries”、“Threadsconnected” 和 “Threadsrunning” 的值，即查询次数、线程连接数和线程运行数。

```
show processlist   //查看运行的线程
```

​:arrow_forward: 返回的 State 的值是我们判断性能好坏的关键：

[state值参考](https://dev.mysql.com/doc/refman/5.7/en/general-thread-states.html)

​:arrow_forward: 使用 MySQL 提供的 explain 查看 SQL 执行计划情况

​:arrow_forward: 使用 profiling 命令可以了解 SQL 语句消耗资源的详细信息( 每个执行步骤的开销 )

[Mysql优化参考](https://www.extlight.com/2017/10/07/MySQL-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/#) 

## Nginx

Nginx (engine x) 是一款轻量级的Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。

Nginx能做什么？

- 反向代理
- 负载均衡
- HTTP服务器（包含动静分离）
- 正向代理

Nginx可以支持热启动，Nginx从新读取配置的命令是：

` nginx -s reload`

> windows下是: 
>
> ​	nginx.exe -s reload

#### 反向代理

​        反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。

```
server {
        listen       80;                                                         
        server_name  localhost;                                               
        client_max_body_size 1024M;

        location / {
            proxy_pass http://localhost:8080;
            proxy_set_header Host $host:$server_port;
        }
    }
```

#### 正向代理

正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。当你需要把你的服务器作为代理服务器的时候，可以用Nginx来实现正向代理。

```
   resolver 114.114.114.114 8.8.8.8;
    server {

        resolver_timeout 5s;

        listen 81;

        access_log  e:\wwwroot\proxy.access.log;
        error_log   e:\wwwroot\proxy.error.log;

        location / {
            proxy_pass http://$host$request_uri;
        }
    }
```

 resolver是配置正向代理的DNS服务器，listen 是正向代理的端口，配置好了就可以在ie上面或者其他代理插件上面使用服务器ip+端口号进行代理了

##### 正向代理与反向代理比较

- 正向代理
  - 正向代理，我们的角色是 **被代理者**
  - 正向代理，我们不对外提供服务，反而是对外消费服务，属于消费者
- 反向代理
  - 反向代理，我们的角色是 **局域网 web服务**
  - 反向代理，我们对外提供服务，属于服务提供者

#### 负载均衡

负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡

常见的几种负载均衡策略：

1. **基于轮询   RR** （默认）

   每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。

简单配置：

```
    upstream test {
        server localhost:8080;
        server localhost:8081;
    }
    server {
        listen       81;                                                         
        server_name  localhost;                                               
        client_max_body_size 1024M;

        location / {
            proxy_pass http://test;
            proxy_set_header Host $host:$server_port;
        }
    }
```

核心代码：

```
 upstream test {
        server localhost:8080;
        server localhost:8081;
    }
```

`upstream`块定义一个后端小集群，里边配置相关的Server组成这个集群，同时`upstream`为这个集群起个相应的名字，本实例叫`test`.

`proxy_pass`处于`location`块中，表示对于所有符合`/`的request，将会交给哪个集群进行处理，本实例为`http://test`

如果协议使用`https`，则将`http`直接改成`https`即可。另外，如果你在`upstream`中的`server`指令中指定了协议名，那么在`proxy_pass`指令中就不需要加上协议名称了。

2. 权重

指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况

```
  upstream test {
        server localhost:8080 weight=9;
        server localhost:8081 weight=1;
    }
```

3. ip_hash

想让对于相同客户端的请求每次都被分发到同一个Server进行处理，上面两种策略都是不做到。此策略可确保来自同一客户端的请求始终定向到同一服务器，但此服务器不可用时除外。既然相同客户端的请求能被同一台Server进行处理，那么相同客户端的会话Session就可以实现持久化了。

```
    upstream test {
        ip_hash;
        server localhost:8080;
        server localhost:8081;
    }
```

4. 基于最少连接数

   该策略主要使用了`least_conn`指令，可以按照机器的实际情况进行刚需分配。

   ```
   upstream myapp1 {
      least_conn;
      server srv1.example.com;
      server srv2.example.com;
      server srv3.example.com;
   }
   ```

5. fair(第三方)

   按后端服务器的响应时间来分配请求，响应时间短的优先分配。

   ```
       upstream backend { 
           fair; 
           server localhost:8080;
           server localhost:8081;
       } 
   ```

6. url_hash（第三方）

   按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法

   ```
       upstream backend { 
           hash $request_uri; 
           hash_method crc32; 
           server localhost:8080;
           server localhost:8081;
       } 
   ```

**负载均衡健康检查**

当我们一个request进来被分发到相应的Server进行处理后，nginx会检查该request执行是否超时，是否执行失败了等情况，然后做出相应的处理；比如说当nginx检查出Server A执行某request时报出502错误了，那么下次nginx负载均衡时就会在`upstream`块中将Server A排除掉，不分发请求给到Server A了。

对于健康检查的功能，nginx提供了基本两个指令，即`max_fails`和`fail_timeout`,也就是说当nginx检查到某Server发生错误的request数达到`max_fails`或者执行某request执行时间超过`fail_timeout`了，如果发生超时了，nginx将开始使用实时请求优雅地探测Server，如果有响应，则认为对应的Server还是活着的，没有毛病的。

**负载均衡的作用**

- 转发功能：按照一定的算法【权重、轮询】，将客户端请求转发到不同应用服务器上，减轻单个服务器压力，提高系统并发量。
- 故障移除：通过心跳检测的方式，判断应用服务器当前是否可以正常工作，如果服务器期宕掉，自动将请求发送到其他应用服务器。
- 恢复添加：如检测到发生故障的应用服务器恢复工作，自动将其添加到处理用户请求队伍中。

#### HTTP服务器

Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现。

动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路

```
upstream test{  
       server localhost:8080;  
       server localhost:8081;  
    }   

    server {  
        listen       80;  
        server_name  localhost;  

        location / {  
            root   e:\wwwroot;  
            index  index.html;  
        }  

        # 所有静态请求都由nginx处理，存放目录为html  
        location ~ \.(gif|jpg|jpeg|png|bmp|swf|css|js)$ {  
            root    e:\wwwroot;  
        }  

        # 所有动态请求都转发给tomcat处理  
        location ~ \.(jsp|do)$ {  
            proxy_pass  http://test;  
        }  

        error_page   500 502 503 504  /50x.html;  
        location = /50x.html {  
            root   e:\wwwroot;  
        }  
    }  
```

##### 正向代理、反向代理、透明代理使用

- 正向代理

  正向代理(forward)是一个位于客户端【用户A】和原始服务器(origin server)【服务器B】之间的服务器【代理服务器Z】，为了从原始服务器取得内容，用户A向代理服务器Z发送一个请求并指定目标(服务器B)，然后代理服务器Z向服务器B转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。

  使用正向代理服务器作用主要有以下几点：

  - 访问本无法访问的服务器B
  - 加速访问服务器B
  - Cache作用
  - 客户端授权访问
  - 隐藏访问者的行踪

- 反向代理

  反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。

  使用反向代理服务器作用如下：

  - 保护和隐藏原始资源服务器
  - 负载均衡

- 透明代理

  透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改变你的request fields(报文)，并会传送真实IP。注意，加密的透明代理则是属于匿名代理，意思是不用设置使用代理了。



## 网络编程

#### TCP/IP

TCP/IP是个协议组，可分为三个层次：网络层、传输层和应用层。 
在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。 
在传输层中有TCP协议与UDP协议。 
在应用层有:TCP包括FTP、HTTP、TELNET、SMTP等协议 
​                    UDP包括DNS、TFTP等协议 

**Socket**

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

#### TCP为何采用三次握手来建立连接

在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接

- 第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
- 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器 进入SYN_RECV状态；
- 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED状态，完成三次握手。

> **三次握手的最主要目的是保证连接是双工的，可靠更多的是通过重传机制来保证的。**

**为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。**

#### 为什么断开TCP连接需要进行四次握手 

立连接后，客户端和服务器都处于`ESTABLISED`状态。这时，客户端发起断开连接的请求：

- 客户端调用 close() 函数后，向服务器发送 FIN 数据包，进入`FIN_WAIT_1`状态。FIN 是 Finish 的缩写，表示完成任务需要断开连接。 

- 服务器收到数据包后，检测到设置了 FIN 标志位，知道要断开连接，于是向客户端发送“确认包”，进入`CLOSE_WAIT`状态。

  :arrow_forward:服务器收到请求后并不是立即断开连接，而是先向客户端发送“确认包”，告诉它我知道了，我需要准备一下才能断开连接

- 客户端收到“确认包”后进入`FIN_WAIT_2`状态，等待服务器准备完毕后再次发送数据包。

- 等待片刻后，服务器准备完毕，可以断开连接，于是再主动向客户端发送 FIN 包，告诉它我准备好了，断开连接吧。然后进入`LAST_ACK`状态。

- 客户端收到服务器的 FIN 包后，再向服务器发送 ACK 包，告诉它你断开连接吧。然后进入`TIME_WAIT`状态。

-  服务器收到客户端的 ACK 包后，就断开连接，关闭套接字，进入`CLOSED`状态。

因为TCP连接是全双工的网络协议，允许同时通信的双方同时进行数据的收发，同样也允许收发两个方向的连接被独立关闭，以避免client数据发送完毕，向server发送FIN关闭连接，而server还有发送到client的数据没有发送完毕的情况。所以关闭TCP连接需要进行四次握手，每次关闭一个方向上的连接需要FIN和ACK两次握手。

#### socket长连接和短连接区别

概念：长连接与短连接的概念：前者是整个通讯过程，客户端和服务端只用一个Socket对象，长期保持Socket的连接；后者是每次请求，都新建一个Socket,处理完一个请求就直接关闭掉Socket。所以，其实区分长短连接就是：整个客户和服务端的通讯过程是利用一个Socket还是多个Socket进行的。

**短连接**

连接->传输数据->关闭连接 
HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。 
也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。 

**长连接 **
连接->传输数据->保持连接 -> 传输数据-> 。。。 ->关闭连接。 
长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。 

> **http的长连接**
> HTTP也可以建立长连接的，使用Connection:keep-alive，HTTP 1.1默认进行持久连接。HTTP1.1和HTTP1.0相比较而言，最大的区别就是增加了持久连接支持(貌似最新的 http1.0 可以显示的指定 keep-alive),但还是无状态的，或者说是不可以信任的。 

#### socket异步与同步区别

**1、异步 **
报文发送和接收是分开的，相互独立的，互不影响。这种方式又分两种情况： 

- 异步双工：接收和发送在同一个程序中，由两个不同的子进程分别负责发送和接收 
- 异步单工：接收和发送是用两个不同的程序来完成。 

**2、同步 **
报文发送和接收是同步进行，即报文发送后等待接收返回报文。 同步方式一般需要考虑超时问题，即报文发出去后不能无限等待，需要设定超时时间，超过该时间发送方不再等待读返回报文，直接通知超时返回。

#### 单工、半双工和全双工

根据通信双方的分工和信号传输方向可将通信分为三种方式：单工、半双工与全双工。在计算机网络中主要采用双工方式，其中：局域网采用半双工方式，城域网和广域网采用全双工方式。

- 单工(Simplex)方式：通信双方设备中发送器与接收器分工明确，只能在由发送器向接收器的单一固定方向上传送数据。采用单工通信的典型发送设备如早期计算机的读卡器，典型的接收设备如打印机。
- 半双工(Half Duplex)方式：通信双方设备既是发送器，也是接收器，两台设备可以相互传送数据，但某一时刻则只能向一个方向传送数据。例如，步话机是半双工设备，因为在一个时刻只能有一方说话。
- 全双工(Full Duplex)方式：通信双方设备既是发送器，也是接收器，两台设备可以同时在两个方向上传送数据。例如，电话是全双工设备，因为双方可同时说话。

## HTTP与HTTPS

#### 简述http与https的区别

1. https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl(Secure Sockets Layer)加密传输协议。
3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

## 安全

#### 简述SHA1,MD5,AES,DES,RSA分别是什么？在什么场景下使用？

**加密技术通常分为两大类:"对称式"和"非对称式"。**

+ **对称性加密算法：**对称式加密就是加密和解密使用同一个密钥。信息接收双方都需事先知道密匙和加解密算法且其密匙是相同的，之后便是对数据进行加解密了。对称加密算法用来对敏感数据等信息进行加密。
+ **非对称算法：**非对称式加密就是加密和解密所使用的不是同一个密钥，通常有两个密钥，称为"公钥"和"私钥"，它们两个必需配对使用，否则不能打开加密文件。发送双方A,B事先均生成一堆密匙，然后A将自己的公有密匙发送给B，B将自己的公有密匙发送给A，如果A要给B发送消息，则先需要用B的公有密匙进行消息加密，然后发送给B端，此时B端再用自己的私有密匙进行消息解密，B向A发送消息时为同样的道理。
+ **散列算法：**散列算法，又称哈希函数，是一种单向加密算法。在信息安全技术中，经常需要验证消息的完整性，散列(Hash)函数提供了这一服务，它对不同长度的输入消息，产生固定长度的输出。这个固定长度的输出称为原输入消息的"散列"或"消息摘要"(Message digest)。散列算法不算加密算法，因为其结果是不可逆的，既然是不可逆的，那么当然不是用来加密的，而是签名。

**对称性加密算法有：AES、DES、3DES**

> 用途： 对称加密算法用来对敏感数据等信息进行加密

- **DES**（Data Encryption Standard）：数据加密标准，速度较快，适用于加密大量数据的场合。
- **3DES**（Triple DES）：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。
- **AES**（Advanced Encryption Standard）：高级加密标准，是下一代的加密算法标准，速度快，安全级别高；AES是一个使用128为分组块的分组加密算法，分组块和128、192或256位的密钥一起作为输入，对4×4的字节数组上进行操作。众所周之AES是种十分高效的算法，尤其在8位架构中，这源于它面向字节的设计。AES 适用于8位的小型单片机或者普通的32位微处理器,并且适合用专门的硬件实现，硬件实现能够使其吞吐量（每秒可以到达的加密/解密bit数）达到十亿量级。同样，其也适用于RFID系统。

**非对称性算法有：RSA、DSA、ECC**

- **RSA**：由 RSA 公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的。RSA在国外早已进入实用阶段，已研制出多种高速的RSA的专用芯片。
- **DSA**（Digital Signature Algorithm）：数字签名算法，是一种标准的 DSS（数字签名标准），严格来说不算加密算法。
- **ECC**（Elliptic Curves Cryptography）：椭圆曲线密码编码学。ECC和RSA相比，具有多方面的绝对优势，主要有：抗攻击性强。相同的密钥长度，其抗攻击性要强很多倍。计算量小，处理速度快。ECC总的速度比RSA、DSA要快得多。存储空间占用小。ECC的密钥尺寸和系统参数与RSA、DSA相比要小得多，意味着它所占的存贮空间要小得多。这对于加密算法在IC卡上的应用具有特别重要的意义。带宽要求低。当对长消息进行加解密时，三类密码系统有相同的带宽要求，但应用于短消息时ECC带宽要求却低得多。带宽要求低使ECC在无线网络领域具有广泛的应用前景。

**散列算法（签名算法）有：MD5、SHA1、HMAC**

> 用途：主要用于验证，防止信息被修改。具体用途如：文件校验、数字签名、鉴权协议

- **MD5**：MD5是一种不可逆的加密算法，目前是最牢靠的加密算法之一，尚没有能够逆运算的程序被开发出来，它对应任何字符串都可以加密成一段唯一的固定长度的代码。
- **SHA1**：是由NISTNSA设计为同DSA一起使用的，它对长度小于264的输入，产生长度为160bit的散列值，因此抗穷举(brute-force)性更好。SHA-1设计时基于和MD4相同原理,并且模仿了该算法。SHA-1是由美国标准技术局（NIST）颁布的国家标准，是一种应用最为广泛的Hash函数算法，也是目前最先进的加密技术，被政府部门和私营业主用来处理敏感的信息。而SHA-1基于MD5，MD5又基于MD4。
- **HMAC**：是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）,HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。也就是说HMAC是需要一个密钥的。所以，HMAC_SHA1也是需要一个密钥的，而SHA1不需要。

**Base64**：其实不是安全领域下的加密解密算法，只能算是一个编码算法，通常用于把二进制数据编码为可写的字符形式的数据，对数据内容进行编码来适合传输(可以对img图像编码用于传输)。这是一种可逆的编码方式。编码后的数据是一个字符串，其中包含的字符为：A-Z、a-z、0-9、+、/，共64个字符，其实是65个字符，“=”是填充字符。

**HTTPS**（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL(SSL使用40 位关键字作为RC4流加密算法)，因此加密的详细内容就需要SSL。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间），提供了身份验证与加密通讯方法；它的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

**区别**

> 1. AES：更快，兼容设备，安全级别高；
> 2. SHA1：公钥后处理回传
> 3. DES：本地数据，安全级别低
> 4. RSA：非对称加密，有公钥和私钥
> 5. MD5：防篡改

**主要应用** 

- 加密算法是可逆的，用来对敏感数据进行保护。散列算法(签名算法、哈希算法)是不可逆的，主要用于身份验证。
- 大量数据加密建议采用对称加密算法，提高加解密速度；小量的机密数据，可以采用非对称加密算法。

## Spring

#### Spring声明式事务

Spring声明式事务管理，通过Spring AOP实现声明式事务管理

事务的四种属性

1. **事务的传播方式**

> 事务传播行为：是指添加事物时的策略

- PROPAGATION_REQUIRED   如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。
- PROPAGATION_SUPPORTS    支持当前事务，如果当前没有事务，就以非事务方式执行。
- PROPAGATION_MANDATORY   使用当前的事务，如果当前没有事务，就抛出异常。
- PROPAGATION_REQUIRES_NEW   新建事务，如果当前存在事务，把当前事务挂起。
- PROPAGATION_NOT_SUPPORTED     以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
- PROPAGATION_NEVER     以非事务方式执行，如果当前存在事务，则抛出异常。
- PROPAGATION_NESTED   如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。

2. **事务隔离级别**

- ISOLATION_DEFAULT：用底层数据库的默认隔离级别
- ISOLATION_READ_UNCOMMITTED（未提交读）：最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）
- ISOLATION_READ_COMMITTED（提交读）：一个事务提交后才能被其他事务读取到（该隔离级别禁止其他事务读取到未提交事务的数据、所以还是会造成幻读、不可重复读）、sql server默认级别
- ISOLATION_REPEATABLE_READ（可重复读）：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（该隔离基本可防止脏读，不可重复读（重点在修改），但会出现幻读（重点在增加与删除））（MySql默认级别，更改可通过set transaction isolation level 级别）
- ISOLATION_SERIALIZABLE（序列化）：代价最高最可靠的隔离级别（该隔离级别能防止脏读、不可重复读、幻读）

>其他概念：
>
>- 丢失更新：两个事务同时更新一行数据，最后一个事务的更新会覆盖掉第一个事务的更新，从而导致第一个事务更新的数据丢失，这是由于没有加锁造成的；
>- 幻读：同样的事务操作过程中，不同时间段多次（不同事务）读取同一数据，读取到的内容不一致（一般是行数变多或变少）。
>- 脏读：一个事务读取到另外一个未提及事务的内容，即为脏读。
>- 不可重复读：同一事务中，多次读取内容不一致（一般行数不变，而内容变了）。

数据库隔离级别越高，执行代价越高，并发执行能力越差，因此在实际项目开发使用时要综合考虑，为了考虑并发性能一般使用提交读隔离级别，它能避免丢失更新和脏读。

3. 事务的超时值
4. 事务的只读标志


## 设计模式

> 工厂模式可以分为三类:
>
> - 简单工厂模式（Simple Factory） 
> - 工厂方法模式（Factory Method） 
> - 抽象工厂模式（Abstract Factory） 
>
> > 这三种模式从上到下逐步抽象，并且更具一般性 
> >
> > 工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。
> >
> > 将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。 

### 工厂方法模式

> 定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。在工厂方法模式中，核心的工厂类不再负责所有的对象的创建，而是将具体创建的工作交给子类去做。这个核心类则摇身一变，成为了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个类应当被实例化这种细节。

- 一个抽象产品类，可以派生出多个具体产品类。   
- 一个抽象工厂类，可以派生出多个具体工厂类。   
- 每个具体工厂类只能创建一个具体产品类的实例。

工厂方法模式组成：

- 抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 
- 具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。 
- 抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 
- 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 

#### 简单工厂模式 

> 属于类的创新型模式，又叫静态工厂方法模式（Static FactoryMethod Pattern）,是通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

 简单工厂模式中包含的角色及其相应的职责:

- 工厂角色（Creator）：这是简单工厂模式的核心，由它负责创建所有的类的内部逻辑。当然工厂类必须能够被外界调用，创建所需要的产品对象。
- 抽象（Product）产品角色：简单工厂模式所创建的所有对象的父类，注意，这里的父类可以是接口也可以是抽象类，它负责描述所有实例所共有的公共接口。
- 具体产品（Concrete Product）角色：简单工厂所创建的具体实例对象，这些具体的产品往往都拥有共同的父类。

**核心思想：有一个专门的类来负责创建实例的过程。**

优点：工厂类是整个模式的关键所在。它包含必要的判断逻辑，能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。用户在使用时可以直接根据工厂类去创建所需的实例，而无需了解这些对象是如何创建以及如何组织的。有利于整个软件体系结构的优化。

缺点：由于工厂类集中了所有实例的创建逻辑，这就直接导致一旦这个工厂出了问题，所有的客户端都会受到牵连；而且由于简单工厂模式的产品室基于一个共同的抽象类或者接口，这样一来，当产品的种类增加的时候，即有不同的产品接口或者抽象类的时候，工厂类就需要判断何时创建何种种类的产品，这就和创建何种种类产品的产品相互混淆在了一起，违背了单一职责，导致系统丧失灵活性和可维护性。而且更重要的是，简单工厂模式违背了“开放封闭原则”，就是违背了“系统对扩展开放，对修改关闭”的原则，因为当我新增加一个产品的时候必须修改工厂类，相应的工厂类就需要重新编译一遍。

### 抽象工厂模式

> 为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。在以下情况下，适用于工厂方法模式:
>
> - (1) 当一个类不知道它所必须创建的对象的类的时候。
> - (2) 当一个类希望由它的子类来指定它所创建的对象的时候。
> - (3) 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。

- 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。   
- 一个抽象工厂类，可以派生出多个具体工厂类。   
- 每个具体工厂类可以创建多个具体产品类的实例。 

### 代理模式

> 为其他对象提供一种代理以控制对这个对象的访问。所谓代理，就是一个人或者机构代表另一个人或者机构采取行动。在一些情况下，一个客户不想或者不能够直接引用一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。
>
> 提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能.

**代理模式的关键点是:代理对象与目标对象.代理对象是对目标对象的扩展,并会调用目标对象.**

#### 静态代理

> 静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类.

**优点**：可以做到在符合开闭原则的情况下对目标对象进行功能扩展。

**缺点**：我们得为每一个服务都得创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得相应修改。

#### 动态代理

>  特点：
>
>  - 代理对象,不需要实现接口
>  - 代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)
>  - 动态代理也叫做:JDK代理,接口代理

**JDK中生成代理对象的API**      代理类所在包 :    ` java.lang.reflect.Proxy`

JDK实现代理只需要使用newProxyInstance方法,

```
static Object newProxyInstance(ClassLoader loader, 
            Class[] interfaces,InvocationHandler h )
```

该方法是在Proxy类中是静态方法,且接收的三个参数依次为:

- ClassLoader loader,:指定当前目标对象使用类加载器,获取加载器的方法是固定的
- Class[] interfaces,:目标对象实现的接口的类型,使用泛型方式确认类型
- InvocationHandler h:事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入

**注意**    代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理

```
/**
* 创建动态代理对象
* 动态代理不需要实现接口,但是需要指定接口类型
*/
public class ProxyFactory{

   //维护一个目标对象
   private Object target;
   public ProxyFactory(Object target){
       this.target=target;
   }

  //给目标对象生成代理对象
   public Object getProxyInstance(){
       return Proxy.newProxyInstance(
               target.getClass().getClassLoader(),
               target.getClass().getInterfaces(),
               new InvocationHandler() {
                   @Override
                   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                       System.out.println("开始事务2");
                       //执行目标对象方法
                       Object returnValue = method.invoke(target, args);
                       System.out.println("提交事务2");
                       return returnValue;
                   }
               }
       );
   }

}
```

```
// 目标对象
IUserDao target = new UserDao();
// 给目标对象，创建代理对象
IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance();
```



#### CGLIB代理

> 以目标对象子类的方式类实现代理
>
> Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.
>
> JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现.
>
> Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉.

**Cglib子类代理实现方法:**

1. 需要引入cglib的jar文件,但是Spring的核心包中已经包括了Cglib功能,所以直接引入spring-core-3.2.5.jar即可.
2. 引入功能包后,就可以在内存中动态构建子类
3. 代理的类不能为final,否则报错
4. 目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法.


> CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理。JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。

```
/**
* Cglib子类代理工厂
* 对UserDao在内存中动态构建一个子类对象
*/
public class ProxyFactory implements MethodInterceptor{
   //维护目标对象
   private Object target;

   public ProxyFactory(Object target) {
       this.target = target;
   }

   //给目标对象创建一个代理对象
   public Object getProxyInstance(){
       //1.工具类
       Enhancer en = new Enhancer();
       //2.设置父类
       en.setSuperclass(target.getClass());
       //3.设置回调函数
       en.setCallback(this);
       //4.创建子类(代理对象)
       return en.create();

   }

   @Override
   public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
       System.out.println("开始事务...");

       //执行目标对象的方法
       Object returnValue = method.invoke(target, args);

       System.out.println("提交事务...");

       return returnValue;
   }
}
```

```
       //目标对象
       UserDao target = new UserDao();
       //代理对象
       UserDao proxy = (UserDao)new ProxyFactory(target).getProxyInstance();
```

> **总结**： 
>
>  **在Spring的AOP编程中:**
>
> 如果加入容器的目标对象有实现接口,用JDK代理.
> 如果目标对象没有实现接口,用Cglib代理.
>
> CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。同时由于CGLib由于是采用动态创建子类的方法，对于final修饰的方法无法进行代理。

### 单例模式

确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。单例模式注意事项：

只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。不要做断开单例类对象与类中静态引用的危险操作。多线程使用单例使用共享资源时，注意线程安全问题。

**实现要点**

- 声明为private来隐藏构造器
- private static Singleton实例
- 声明为public来暴露实例获取方法

单例模式主要追求三个方面性能

- 线程安全
- 调用效率高
- 延迟加载

> 单例模式有很多好处，它能够避免实例对象的重复创建，不仅可以减少每次创建对象的时间开销，还可以节约内存空间；能够避免由于操作多个实例导致的逻辑错误。如果一个对象有可能贯穿整个应用程序，而且起到了全局统一管理控制的作用，那么单例模式也许是一个值得考虑的选择。

#### 饿汉模式

```

public class Singleton{
    private static Singleton instance = new Singleton();
    private Singleton(){}
    public static Singleton newInstance(){
        return instance;
    }
}
```

> 好处是只在类加载的时候创建一次实例，不会存在多个线程创建多个实例的情况，避免了多线程同步的问题。它的缺点也很明显，即使这个单例没有用到也会被创建，而且在类加载之后就被创建，内存就被浪费了。
>
> 这种实现方式适合单例占用内存比较小，在初始化时就会被用到的情况。

#### 懒汉模式

```
public class Singleton{
    private static Singleton instance = null;
    private Singleton(){}
    public static Singleton newInstance(){
        if(null == instance){
            instance = new Singleton();
        }
        return instance;
    }
}
```

> 懒汉模式中单例是在需要的时候才去创建的，如果单例已经创建，再次调用获取接口将不会重新创建新的对象，而是直接返回之前创建的对象。
>
> 这里的懒汉模式并没有考虑线程安全问题，在多个线程可能会并发调用它的getInstance()方法，导致创建多个实例，因此需要加锁解决线程同步问题

**加锁版本**

```
public class Singleton{
    private static Singleton instance = null;
    private Singleton(){}
    public static synchronized Singleton newInstance(){
        if(null == instance){
            instance = new Singleton();
        }
        return instance;
    }
}
```

#### 双重校验锁

> 加锁的懒汉模式看起来即解决了线程并发问题，又实现了延迟加载，然而它存在着性能问题，依然不够完美。synchronized修饰的同步方法比一般方法要慢很多，如果多次调用getInstance()，累积的性能损耗就比较大了。因此就有了双重校验锁

```
public class Singleton {
    private static volatile Singleton instance = null;
    private Singleton(){}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

volatile的一个语义是禁止指令重排序优化，也就保证了instance变量被赋值的时候对象已经是初始化过的

#### 静态内部类

```
public class Singleton{
    private static class SingletonHolder{
        public static Singleton instance = new Singleton();
    }
    private Singleton(){}
    public static Singleton newInstance(){
        return SingletonHolder.instance;
    }
}
```

> 利用了类加载机制来保证只创建一个instance实例。它与饿汉模式一样，也是利用了类加载机制，因此不存在多线程并发的问题。不一样的是，它是在内部类里面去创建对象实例。这样的话，只要应用中不使用内部类，JVM就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载。也就是说这种方式可以同时保证延迟加载和线程安全。

#### 枚举

```
public enum Singleton{
    instance;
    public void whateverMethod(){}    
}
```

> 其他的四种实现单例的方式都有共同的缺点：
>
> - 需要额外的工作来实现序列化，否则每次反序列化一个序列化的对象时都会创建一个新的实例。
> - 可以使用反射强行调用私有构造器
>
> 而枚举类很好的解决了这两个问题，使用枚举除了线程安全和防止反射调用构造器之外，还提供了自动序列化机制，防止反序列化的时候创建新的对象。

- 线程安全

- 由于枚举类的会在编译期编译为继承自java.lang.Enum的类，其构造函数为私有，不能再创建枚举对象，枚举对象的声明和初始化都是在static块中，所以由JVM的ClassLoader机制保证了线程的安全性。但是不能实现延迟加载

- 序列化

  由于枚举类型采用了特殊的序列化方法，从而保证了在一个JVM中只能有一个实例

**单例模式性能总结**

| 方式     | 优点                | 缺点     |
| ------ | ----------------- | ------ |
| 饿汉式    | 线程安全，调用效率高        | 不能延迟加载 |
| 懒汉式    | 线程安全，可以延长加载       | 调用效率不高 |
| 双重校验锁式 | 线程安全，调用效率高，可以延长加载 |        |
| 静态内部类式 | 线程安全，调用效率高，可以延长加载 |        |
| 枚举单例   | 线程安全，调用效率高        | 不能延迟加载 |

**其他参考** ：[单例模式的破坏与防御](https://blog.csdn.net/jq_ak47/article/details/54894793)

## JVM

### JVM加载class文件的原理机制

### Java垃圾回收机制





 